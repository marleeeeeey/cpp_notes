### 01. Строки

- `SSO` (Small String Optimazations) делает так, что `data` ссылается на память на `стеке`, где находится короткая строка.

### 02. Functions template

- Статический полиморфизм: множество перегрузок и шаблон функции. Динамический полиморфизм: виртуальная фукнция.
- Вместо слова `typename` можно использовать `имя концепта`: `template <std::integral T> void foo(T t)`.
- `Инстанцирование` - это процесс порождения экземпляра специализации. Может быть `явным` или `неявным`.
- `non-type template parameter` можно также **параметризовать указателями** на `nullptr`, на `глобальную память` или `статические объекты`.
- **Выбор пользовательского преобразования зависит от длины хвоста стандартных преобразований**. Голова не участвует в конкурсе.

### 03. Class template

- Переходник типов `Type2Type<T1>` - позволяет решить проблему специализации метода класса по параметру шаблона класса
- Можно использовать `iterator_traits<Iter>::value_type`, а можно написать просто `Iter::value_type`. Однако `iterator_traits` предпочтительнее, потому что он умеет выводить типы для указателей, у которых нет вложенного типа `value_type`.
- **Конструкторы** классов могут использоваться для **вывода типов шаблона класса**.
- `Deduction Hints` - хинты вывода типов могут быть использованы для вывода типов `конструкторами классов` и `агрегатами` (С++17).

### 04. Modules

- `inline` - НОВОЕ ЗНАЧЕНИЕ: означает исключение из ODR. Т.е. чтобы она была в header файле, но одна на все единицы трансляции.
- `inline` нужно использовать в **специализациях шаблонов**, которые специализированы **в header файле**.
- `inline` не влияет на связывание. Функция одна все все единицы трансляции. Это weak функция, и линковщик берет первую попавшуюся.
- `if constexpr` влияет на инстанцирование и на ODR. `if constexpr(false)` - внутренности не попадают под `ODR`.
- `namespaces` ортогональны модулям.

### 05. SFINAE

- Настоящее место SFINAE - выкрутится там, где не хватает средств языка.

### 06. Constexpr

- `constexpr` - не входит в cdecl.
- `if constexpr` - выкидывает ветки шаблонных инстанцирований. Дурной тон - использовать `if constexpr` вне процесса инстанцирования.
- `constexpr переменная` - всегда на этапе компиляции. `constexpr функция` - может быть вызывана во время компиляции и во время выполнения.
- Невозможно создать локальную `constinit` переменную.
- `if consteval` (C++23) - помогает узнать внутри функции, находимся мы на этапе компиляции или на этапе выполнения.
- В `C++14` добавился процесс `constexpr-evaluation` к таким процессам, как инстанцирование вывод типов и подобное.
- Constexpr SFINAE характеристик - является концептом.
- В `constexpr-функциях` на этапе компиляции запрещено UB. Возникает `compile-time error`. Поэтому их можно использовать как санитайзеры.

### 07. Concepts

- `devlal<T>()` - позволяет создать ссылку на объект, даже если у него запрещен конструктор.
- Костыль: Используем `SFINAE`, чтобы сделать более `явным интерфейс`. Способы:
  - (1) Ввести шаблонный параметр без имени (потому что не используем): `typename = std::enable_if_t <is_equality_comparable<T, U>::value>>`
  - (2) Испортить возвращаемый тип (усложняется перегрузка, потому что по возвращаемому значению перегружать нельзя).
  - (3) Испортить один из параметров функции (получаем испорченный вывод типов).
- Constrains (`requires`) не определяют частичный порядок.
- Концепты (`requires requires` и `concept`) определяют над собой частичный порядок (частное-общее).

### 09. Type Inference (Вывод типов)

- Категории характеризуют выражения, но не типы.

- Категории выражений:
  - `prvalue`- это рецепт для построения объекта, но не сам объект. **Не имеет локации в памяти**, но может быть преобразовано в `xvalue`.
  - `xvalue` - (Expiring Value) образуется, когда мы вызываем `std::move` на объекте, что означает, что объект **имеет локацию** в памяти и **может быть перемещен**.
  - `lvalue` - (Locator Value) - это объект, который **имеет локацию** в памяти и **не может быть перемещен**.

- У `rvalue` всегда есть дефолтный конструктор, даже если у объекта удалён конструктор.
  - Это позволяет использовать `declval` для создания выражений, которые можно использовать в `decltype`, чтобы получить нужный тип, не создавая реальный объект.
- Надо различать вызван ли `decltype` от `имени` или от `выражения`.
  - Для `имени` он выводит тип переменной, как она была объявлена.
  - Для `lvalue выражений` он добавляет `&`.
  - Для `xvalue выражений` он добавляет `&&`.
  - Для `prvalue выражений` он ничего не добавляет.

- `decltype(auto)` ведет себя как `decltype`, но при этом выводится из всей правой части.
  - Если правая часть — это имя, то `decltype` работает по правилам работы с именами,
  - а если правая часть — это выражение, то `decltype` работает по правилам работы с выражениями.
- `auto` можно уточнять концептами: `void sort(Sortable auto&);`
- Никогда не используйте `негативные ограничения` для шаблонов. Негативные ограничения ограничивают типы, которые "дурно пахнут", но могут зацепить другие типы, которые вы не хотите пропускать в функцию.
