- 01. Scent Cpp
  - `class` используется для объединения данных и методов.
  - `template` используется для обобщения данных и методов.
  - `STL` - стандартная библиотека имеет массу обобщенных алгоритмов и структур данных.
- 02. Указатели и ссылки
  - `ссылка` - это другое имя оъекта. Не может быть `nullptr`.
  - `указатель` - это объект, который хранит адрес другого объекта. Может быть `nullptr`.
  - `const T&` - только const ссылка может продлевать жизнь временного объекта (rvalue).
  - `decaying` - это процесс превращения массива в указатель. Деградация.
  - `lvalue` означает locator value. Хотя раньше означало left value, т.е. значение слева от оператора присваивания.
  - Переменная в `global scope`  имеет `static storage duration`. `Порядок инициализации` внутри модуля строго сверху вниз. Между модулями порядок не определен.
- 03. Перегрузка. Конструкторы/деструкторы. Копирование/присваивание.
  - `mangling` - это процесс преобразования имен функций во что-то уникальное.
  - `Строгая гарантия по именам` - ее предоставляет язык Си. В С++ есть `extern "C"`, т.к. в нем нет перегрузки. За это любят Си.
  - `Конструкторы можно делегировать` через `: Base(args) {}`.
  - Отличие копирования от присваивания: 1. Копирование - создание нового объекта, 2. Присваивание - изменение существующего объекта.
  - `volatile` - это квалификатор, который говорит компилятору, что переменная может измениться вне текущего контекста.
  - Пользовательские преобразования: 1. Constructor от одного аргумента, 2. Operator преобразования.
- 04. RAII и перемещение
  - `operator->` предоставляет доступ к внутренним полям, но не дает доступа к указателю на объект, хотя и возвращает указатель на объект. Как бы зарывается в глубину.
  - `move/copy elision` может работать, даже если копирование или перемещение удалены.
  - `std::move на return` может убить RVO(Return Value Optimization).
  - `Правило пяти` - это 1. Конструктор копирования, 2. Оператор присваивания, 3. Конструктор перемещения, 4. Оператор перемещения, 5. Деструктор.
  - `NoCopyMove bar() { return NoCopyMove{}; }` // легально в C++17 - prvalue elision
  - `NoCopyMove n = bar();` // легально в C++17 - prvalue elision
  - `foo(NoCopyMove{});` // легально в C++17 - обязан делать copy/move elision
- 05. Operators
  - Касты: 1. `static_cast`, 2. `dynamic_cast`, 3. `const_cast`, 4. `reinterpret_cast`.
  - `Равенство и эквивалентность` - это разные вещи. `==` и `!=` - это равенство. `operator<` - это эквивалентность.
  - `->*` или `.*` - это операторы для работы с указателями на члены.
  - `operator""` - это пользовательские литералы.
- 06. Inheritance
  - `Срезка значения` может происходить, если объект передается по значению.
  - `Empty Base Class Optimization` - оптимизация, когда пустой базовый класс не занимает места. Не работает для виртуальных базовых классов.
  - `Аргументы по умолчанию` связываются `статически`. `Виртуальные функции` связываются `динамически`.
  - `Статический полиморфизм`: 1. Полиморфизм функций, 2. Полиморфизм шаблонов.
  - `Динамический полиморфизм` - это полиморфизм через виртуальные функции. Полиморфизм по аргументу `this`.
  - `Множественное наследование` и ромбовидность решается через `virtual inheritance`.
  - `dynamic_cast` на порядки может быть медленнее, чем `static_cast`. При отсутвии виртуальных функций, `dynamic_cast` работает как `static_cast`.
- 08. Exceptions
  - `Гарантии безопасности исключений`: 1. Базовая (нет утечек, но состояние объекта непредсказуемое), 2. Строгая (commit/rollback), 3. noexcept.
  - `Условный noexcept` - делается через operator `noexcept`. Не путать с аннотацией `noexcept`.
  - `copy and swap` - это идиома для создания exception-safe методов.
  - `new` - бывает трех типов: 1. `new`, 2. `nothrow new`, 3. `placement new`.
- 12. Templates
  - `rvalue` объект можно передать в `const T&` - это своего рода исключение из праввил.
  - `universal reference` - это шаблонный `T&&`. Может быть `lvalue` и `rvalue`, но сам является `lvalue`.
  - `std::forward` - это условный `std::move`.
  - `decltype` - возвращает тип выражения. Может добавлять `&`.
  - `auto` - выводит тип переменной из выражения. Срезает ссылки и квалификаторы. Делает `decay`. Работает по правилам шаблонного вывода.
  - `decltype(auto)` - выводит тип переменной из выражения справа. Не делает `decay`.
  - `void_t` - это своего рода коньюнкция типов. Проверяет, что все типы легальны, либо Substitution Failure.
  - `Итератор`, это объект, у которого есть методы ++, *, <=>, begin, end.
- 13. Vectors
  - `Integral Constant` - отражение из целых чисел в типы. `true_type` и `false_type`.
  - `Шаблонная триада`: 1. Primary template, 2. Partial specialization, 3. Удобный `using func_t`.
  - `{}` инициализация: 1. Агрегат, 2. initializer_list, 3. конструктор.
  - `Вариативные шаблоны` захватывают все аргументы, которые не были захвачены ранее.
