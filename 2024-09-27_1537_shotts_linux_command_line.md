# William Shotts - The Linux Command Line

- [Часть I. Командная оболочка](#часть-i-командная-оболочка)
  - [Глава 1. Что такое командная оболочка](#глава-1-что-такое-командная-оболочка)
  - [Глава 2. Навигация](#глава-2-навигация)
  - [Глава 3. Исследование системы](#глава-3-исследование-системы)
  - [Глава 4. Операции с файлами и каталогами](#глава-4-операции-с-файлами-и-каталогами)
  - [Глава 5. Работа с командами](#глава-5-работа-с-командами)
  - [Глава 6. Перенаправление](#глава-6-перенаправление)
  - [Глава 7. Взгляд на мир глазами командной оболочки](#глава-7-взгляд-на-мир-глазами-командной-оболочки)
  - [Глава 8. Продвинутые приемы работы с клавиатурой](#глава-8-продвинутые-приемы-работы-с-клавиатурой)
  - [Глава 9. Привилегии](#глава-9-привилегии)
  - [Глава 10. Процессы](#глава-10-процессы)
- [Часть II. Окружение и настройка](#часть-ii-окружение-и-настройка)
  - [Глава 11. Окружение](#глава-11-окружение)
  - [Глава 12. Плавное введение в vi](#глава-12-плавное-введение-в-vi)
  - [Глава 13. Настройка приглашения к вводу](#глава-13-настройка-приглашения-к-вводу)
- [Часть III. Типичные задачи и основные инструменты](#часть-iii-типичные-задачи-и-основные-инструменты)
  - [Глава 14. Управление пакетами](#глава-14-управление-пакетами)
  - [Глава 15. Устройства хранения](#глава-15-устройства-хранения)
  - [Глава 16. Сети](#глава-16-сети)
  - [Глава 17. Поиск файлов](#глава-17-поиск-файлов)
  - [Глава 18. Архивация и резервное копирование](#глава-18-архивация-и-резервное-копирование)
  - [Глава 19. Регулярные выражения](#глава-19-регулярные-выражения)
  - [Глава 20. Обработка текста](#глава-20-обработка-текста)
  - [Глава 21. Форматирование вывода](#глава-21-форматирование-вывода)
  - [Глава 22. Печать](#глава-22-печать)
  - [Глава 23. Компиляция программ](#глава-23-компиляция-программ)
- [Часть IV. Сценарии командной оболочки](#часть-iv-сценарии-командной-оболочки)
  - [Глава 24. Создание первого сценария командной оболочки](#глава-24-создание-первого-сценария-командной-оболочки)
  - [Глава 25. Начало проекта](#глава-25-начало-проекта)
  - [Глава 26. Проектирование сверху вниз](#глава-26-проектирование-сверху-вниз)
  - [Глава 27. Управление потоком выполнения: ветвление при помощи if](#глава-27-управление-потоком-выполнения-ветвление-при-помощи-if)
  - [Глава 28. Чтение ввода с клавиатуры](#глава-28-чтение-ввода-с-клавиатуры)
  - [Глава 29. Управление потоком выполнения: циклы while и until](#глава-29-управление-потоком-выполнения-циклы-while-и-until)
  - [Глава 30. Поиск и устранение ошибок](#глава-30-поиск-и-устранение-ошибок)
  - [Глава 31. Управление потоком выполнения: ветвление с помощью case](#глава-31-управление-потоком-выполнения-ветвление-с-помощью-case)
  - [Глава 32. Позиционные параметры](#глава-32-позиционные-параметры)
  - [Глава 33. Управление потоком выполнения: цикл for](#глава-33-управление-потоком-выполнения-цикл-for)
  - [Глава 34. Строки и числа](#глава-34-строки-и-числа)
  - [Глава 35. Массивы](#глава-35-массивы)
  - [Глава 36. Экзотика](#глава-36-экзотика)

## Часть I. Командная оболочка

### Глава 1. Что такое командная оболочка

- Командная оболочка - это программа, которая принимает команды, введенные с клавиатуры, и передает их операционной системе для выполнения.
- Примеры командных оболочек: `bash`, `tcsh`, `zsh`, `ksh`, `sh`.
- Эмулятор терминала - это программа, которая позволяет вводить команды в командную оболочку.
- Примеры эмуляторов терминала: `xterm`, `gnome-terminal`, `konsole`, `rxvt`, `aterm`.
- Приглашение к вводу, пример: `user@hostname:~$`.
- Знак суперпользователя - `#`.
- Основные клавиши и команды
  - KeyUp, KeyDown - перемещение по истории команд.
  - `date` - вывод текущей даты и времени.
  - `cal` - вывод календаря.
  - `df` - вывод информации о дисковом пространстве.
  - `free` - вывод информации о памяти.
  - `exit` - выход из командной оболочки.

### Глава 2. Навигация

- В Unix-подобных системах всегда имеется только одна файловая система, начинающаяся с корневого каталога `/`.
- Устройсва хранения данных монтируются в каталоги.
- `pwd` - вывод текущего рабочего каталога.
- `ls` - вывод содержимого каталога.
- `cd` - смена рабочего каталога (cd - change directory).
  - `cd ~user` - переход в домашний каталог пользователя.
- `.` - текущий каталог.
- `..` - родительский каталог.

### Глава 3. Исследование системы

- `ls ~ /` - вывод содержимого домашнего каталога и корневого каталога.
- `ls -l` - вывод содержимого каталога в виде списка (l = long).
- **Мнемоника: `command -option argument`**.
- `ls -lt` - вывод содержимого каталога в виде списка, отсортированного по времени последнего изменения.
  - `l` - long, `t` - time.
- `ls -r` - вывод содержимого каталога в обратном порядке.
- `ls -d` - вывод информации о каталоге, а не его содержимом.
- `ls -S` - сортировка по размеру.
- Пример длинного формата вывода: `-rw-r--r-- 1 user user 0 Sep 27 15:37 file.txt`.
  - `-rw-r--r--` - права доступа.
    - `pos1` - тип файла: `-` - обычный файл, `d` - каталог, `l` - символическаак ссылка.
    - `pos2-4` - права доступа владельца.
    - `pos5-7` - права доступа группы.
    - `pos8-10` - права доступа остальных пользователей.
  - `1` - количество жестких ссылок.
  - `user user` - владелец и группа.
  - `0` - размер в байтах.
  - `Sep 27 15:37` - дата последнего изменения.
  - `file.txt` - имя файла.
- `file file.txt` - вывод информации о типе файла.
- `less file.txt` - просмотр содержимого файла.
  - `q` - выход.
  - `KeyUp`, `KeyDown` - перемещение по тексту.
  - `1G` - переход в начало файла.
  - `/pattern` - поиск строки.
  - `n` - следующее вхождение.

- **Каталоги в системе linux**
  - `/` - корневой каталог.
  - `/bin` - исполняемые файлы, необходимые для загрузки системы.
  - `/boot` - содержит ядро Linux, образ начального RAM-диска и файлы загрузчика.
  - `/dev` - файлы устройств.
  - `/etc` - конфигурационные файлы.
    - `/etc/passwd` - список всех пользователей.
    - `/etc/crontab` - расписание задач.
    - `/etc/fstab` - таблица монтирования.
  - `/home` - домашние каталоги пользователей.
  - `/lib` - библиотеки, необходимые для работы программ.
  - `/media` - точка монтирования для съемных носителей.
  - `/mnt` - точка монтирования для временных файловых систем.
  - `/opt` - дополнительное программное обеспечение.
  - `/proc` - виртуальная файловая система, содержащая информацию о процессах. Позволяет заглянуть в ядро.
  - `/root` - домашний каталог суперпользователя.
  - `/sbin` - исполняемые файлы, необходимые для загрузки системы. Запускаются суперпользователем.
  - `/tmp` - временные файлы.
  - `/usr` - вторичная иерархия каталогов, содержащая исполняемые файлы, библиотеки, заголовочные файлы и документацию обычных пользователей.
    - `/usr/bin` - исполняемые файлы.
    - `/usr/include` - заголовочные файлы.
    - `/usr/lib` - библиотеки.
    - `/usr/local` - дополнительное программное обеспечение. Не входит в состав дистрибутива, но доступно для всех пользователей.
    - `/usr/sbin` - Содержит дополнительные программы для администрирования.
    - `/usr/share` - общие данные. Конфигурационные файлы, документация, иконки.
    - `/usr/share/doc` - документация по установленным пакетам.
    - `/usr/share/man` - справочные страницы.
    - `/var` - содержит изменяемые файлы, такие как журналы, временные файлы, почту и т.д.
      - `/var/log` - журналы.
      - `/var/spool` - почта и принтеры.
      - `/var/tmp` - временные файлы.

### Глава 4. Операции с файлами и каталогами

- Wildcards: `*`, `?`, `[]`, [simbols], [!simbols], [[:class:]].
- `mkdir` - создание каталога.
- `cp source.txt dest.txt` - копирование файла.
  - `cp -a` - копирование со всеми атрибутами.
  - `cp -i` - запрос на подтверждение.
  - `cp -r` - рекурсивное копирование.
  - `cp -u` - копирование только новых файлов.
  - **`cp -v` - подробный вывод.**
- `mv source.txt dest.txt` - перемещение файла. Работает аналогично `cp`.
- `rm file.txt` - удаление файла.
  - `rm -i` - запрос на подтверждение.
  - `rm -r` - рекурсивное удаление.
  - `rm -f` - удаление без запроса на подтверждение.

- **Жесткие ссылки**
  - По умолчанию каждый файл имеет одну жесткую ссылку.
  - Жесткая ссылка не может указывать на файл за пределами собственной файловой системы.
  - Влияют на время жизни файла. Когда удаляется последняя жесткая ссылка, файл удаляется.
  - Создавая жесткую ссылку, мы фактически создаем дополнительнйы раздел с именем, ссылающийся на тот же раздел с данными.
  - `inode` - структура данных, содержащая информацию о файле. Т.е. каждая жесткая ссылка ссылается на определенный индексный узел с содержимым файла.
  - `ln file.txt link.txt` - создание жесткой ссылки.

- **Символические ссылки**
  - Были придуманы, чтобы преодолеть ограничения жестких ссылок. Могут ссылаться на файлы вне текущей файловой системы.
  - Может провиснуть, если целевой файл удален.
  - Символическая ссылка не влияет на время жизни файла.
  - Операции над симолической ссылкой применяются к целевому файлу, кроме команд `rm`, которая удаляет саму ссылку.
  - `ln -s file.txt link.txt` - создание символической ссылки.

### Глава 5. Работа с командами

- **Чем могут быть команды в Linux**
  - Скомпилированные программы. Например в папке `/usr/bin`. Например `ls`, `cp`, `mv`.
  - `shell builtins` - встроенные команды оболочки. Например `cd`, `echo`, `exit`.
  - `shell functions` - функции оболочки. Мини сценарии, встроенные в окружение.
  - `aliases` - псевдонимы команд. Например `alias ll='ls -l'`.

- **Команды**
  - `type` - вывод типа команды.
  - `which` - вывод пути к исполняемому файлу. Ищет только скомпилированные программы.
  - `--help` - вывод краткой справки по использованию. Например `ls --help`.
  - `man` - вывод справочного руководства со ссылками. Например `man ls`.
    - `man 1 ls` - вывод справки по команде `ls`.
    - `man 5 passwd` - вывод справки по файлу `/etc/passwd`.
    - Т.е. `man section command`. Где `section` - номер раздела справки.
  - `apropos` - поиск по ключевым словам в справке. Например `apropos copy`.
    - То же самое что `man -k`.
  - `whatis` - вывод краткой информации о команде. Например `whatis ls`.
  - `info` - вывод информации о команде в формате `info`. Например `info ls`. Кликабельные ссылки.
    - `info coreutils` - вывод информации о пакете `coreutils`.

- **Разделение команд**
  - Разделение команд `;`, чтобы выполнить несколько команд подряд в одной строке. Например `ls; pwd`.

- **Алиасы**
  - Создание алиасов `alias ll='ls -l'`.
  - Удаление алиасов `unalias ll`.
  - Алиасы изчезают после завершения сеанса.

### Глава 6. Перенаправление

- **Потоки**
  - `stdin` - стандартный поток ввода.
  - `stdout` - стандартный поток вывода. Дескриптор 1.
  - `stderr` - стандартный поток ошибок. Дескриптор 2.

- **Перенаправление вывода**
  - `ls -l /usr/bin > ls-output.txt` - **перенаправление потока вывода** в файл. **Перезапись**. Дескриптор 1 по умолчанию.
  - `ls -l /usr/bin >> ls-output.txt` - перенаправление вывода в файл. **Добавление**. Дескриптор 1 по умолчанию.
  - `ls -l /usr/bin 2> ls-error.txt` - **перенаправление ошибок** в файл. Перезапись. Дескриптор 2.
  - `ls -l /bin/usr > ls-output.txt 2>&1` - **перенаправление всего вывода** в файл (stdout и stderr).
    - Порядок перенаправления важен. Сначала указывается stdout, затем stderr.
    - `ls -l /bin/usr &> ls-output.txt` - **Более короткая запись**.
  - `ls -l /bin/usr 2> /dev/null` - удаление нежелательного ввода. Перенаправление в `/dev/null`.
    - `/dev/null` - специальный файл, который игнорирует все, что в него пишется.

- **cat - конкатенация или вывод содержимого файлов**
  - `cat file1.txt file2.txt` - вывод содержимого файлов. Выводит по очереди их содержимое и получается конкатенация.
    - `cat` - без аргументов, копирует стандартный ввод в стандартный вывод. Нажать `Ctrl+D`(EOF) для завершения.
    - `cat < file.txt` - перенаправление файла в стандартный ввод. Результат тот же, что и `cat file.txt`.

- **Конвейер** `cmd1 | cmd2`. Стандартный вывод одной команды передается в стандартный ввод другой.
  - `ls -l /usr/bin | less` - вывод содержимого каталога постранично.

- **Фильтры** - принимают ввод, изменяют его определенным образом и выводят результат.
  - `sort` - сортировка строк: `ls -l /usr/bin | sort | less`.
  - `uniq` - вывод уникальных строк: `ls -l /usr/bin | sort | uniq | less`.
    - `uniq -d` - вывод дубликатов.
  - `wc` - подсчет строк, слов и символов: `ls -l /usr/bin | wc`.
    - `wc -l` - подсчет строк.
    - `wc -w` - подсчет слов.
    - `wc -c` - подсчет символов.
  - **`grep` - поиск строк по шаблону(регулярные выражения): `ls -l /usr/bin | grep zip`**.
    - `grep -v` - вывод строк, не содержащих шаблон.
    - `grep -i` - игнорирование регистра.
    - `grep -c` - подсчет строк.
    - `grep -n` - вывод номеров строк.
    - **`grep -r` - рекурсивный поиск**.
  - `head` - вывод начала файла: `ls -l /usr/bin | head`.
    - `head -n 10` - вывод первых 10 строк.
  - `tail` - вывод конца файла: `ls -l /usr/bin | tail`.
    - `tail -n 10` - вывод последних 10 строк.
    - **`tail -f` - вывод конца файла в реальном времени**.
  - `tee` - Т-образное разветвление потока вывода (например в файл и на экран): `ls -l /usr/bin | tee ls-output.txt | less`.
    - Сохраняет вывод команды, передаваемый через конвейер (в данном случае — `ls /usr/bin`), в файл и одновременно передает его в конвейер для дальнейшей обработки.

### Глава 7. Взгляд на мир глазами командной оболочки

- **Подстановка**
  - После нажатия `Enter` командная оболочка автоматически производит подстановку любых условных символов в командной строке, прежде чем выполнить ее.
  - `echo *` - подстановка имен файлов в текущем каталоге. Команда `echo` видит уже результат подстановки.

- **Подстановка путей (Pathname expansion)**
  - `*` - подстановка любого количества символов.
  - `?` - подстановка одного символа.
  - `[...]` - подстановка одного символа из набора.
  - `[!...]` - подстановка одного символа не из набора.
  - `[[:...:]]` - подстановка символов из класса символов.
  - `ls -l /usr/bin/[a-c]*` - подстановка файлов, начинающихся с буквы `a`, `b` или `c`.
  - **`ls -d .[!.]?*` - шаблон для поиска скрытых файлов**.

- **Подстановка результатов арифметических выражений**
  - `echo $((2 + 2))` - подстановка результата арифметического выражения.
  - Операторы: `+`, `-`, `*`, `/`, `%`, `**`.

- **Подстановка фигурных скобок**
  - Позволяет создавать множество текстовых строк из шаблонов. Начальная часть шаблона называется преамбулой, а конечная — эпилогом.
  - Использование пробелов внутри скобок не допускается.
  - `echo Front-{A,B,C}-Back` - подстановка всех комбинаций в фигурных скобках.
  - `mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12}` - создание каталогов.

- **Подстановка переменных**
  - `printenv` - вывод переменных окружения.
  - `echo $USER` - подстановка значения переменной.
  - `echo $((2 * $1))` - подстановка значения аргумента командной строки.
  - `echo $((2 * $#))` - подстановка количества аргументов командной строки.
  - `echo $((2 * $RANDOM))` - подстановка случайного числа.

- **Подстановка команд**
  - `echo $(ls)` - подстановка вывода команды.
  - `ls -l $(which cp)` - подстановка полного пути к исполняемому файлу.
  - `file $(ls /usr/bin/* | grep zip)` - выводит краткую информацию о файлах, содержащих `zip`.
  - Старые оболочки вместо `$(...)` использовали обратные кавычки `` `...` ``.

- **Экранирование**
  - `echo Hello $100.00` - ОШИБКА. Будет попытка подстановки пустой строки вместо $1.
  - `echo $(cal)` - удаляет пробелы и табуляции из вывода команды `cal`. Используйте кавычки для сохранения пробелов.
    - Вне кавычек пробелы считаются разделиителями аргументов.

- **Двойные кавычки** `"` - экранируют все символы, кроме `$`, `\` и `"`.
  - Подстановка параметров, значений переменных, арифметических выражений и команд все еще выполняется: `echo "$USER $((2+2)) $(cal)"`.
  - Все специальные символы внутри двойных кавычек теряют свою специальность, кроме `$`, `\` и `"`.
  - Благодаря двойным кавычкам вы можете обрабатывать строки, содержащие пробелы.

- **Одинарные кавычки** `'` - экранируют все символы.
  - `echo '$USER $((2+2)) $(cal)'` - выводит буквально строку внутри кавычек **без подстановок**: `$USER $((2+2)) $(cal)`.

- **Экранирование одного символа**
  - `echo \$USER` - выводит `$USER` без подстановки переменной.
  - Можно использоват чтобы включить специальные символы (`$`, `!`, `&`, ` `) в имена файлов: `ls -l \$file`.

### Глава 8. Продвинутые приемы работы с клавиатурой

- **Цели командной строки**
  - Выполнить большую часть работы всего несколькими нажатиями клавиш.
  - Избежать использования мыши.

- **Полезные для меня сочетания из книги**
  - `Ctrl+L` - очистка экрана.
  - `Alt+T` - обмен местами словами.
  - `Alt+L`, `Alt+U` - преобразование слов в нижний и верхний регистр.
  - `Ctrl+U` , `Ctrl+K`, `Alt+D` - удаление строки, до курсора, до конца слова.
  - `TAB` - автодополнение. Работает с
    - командами (когда дополняемое слово является первым в командной строке),
    - файлами,
    - именами переменных (если слово начинается с `$`),
    - именами копьютеров (если слово начинается с `@`),
    - именами пользователей (если слово начинается с `~`).

- **История команд**
  - `history` - вывод истории команд.
  - `.bash_history` - файл истории команд.
  - `!<number>` - выполнение команды из истории по номеру.
  - `!!` - выполнение последней команды.
  - `Ctrl+R` - поступательный поиск по истории команд.
    - Закончив поиск, нажмите `Enter`, чтобы выполнить команду.
    - Нажмите `Ctrl+J`, чтобы скопировать найденную команду в командную строку, не выполняя ее.
    - `Ctrl+R` - чтобы найти следующее вхождение.
    - `Ctrl+С`, `Ctrl+G` - чтобы выйти из режима поиска.
  - `!<string>` - выполнение последней команды, начинающейся с `<string>`.
  - `!?<string>` - выполнение последней команды, содержащей `<string>`.

### Глава 9. Привилегии

- Unix системы в отличие от MS-DOS являются **многопользовательскими** в дополнение к многозадачности.
  - Несколько пользователей могут одновременно работать на одной системе подключившись к ней через ssh.
  - Пользователи могут получать изображения рабочего стола `ssh -X user@hostname`.

- **Владение**
  - Пользователи могут владеть файлами и каталогами.
  - Пользователи могут принадлежать группам, которые могут владеть файлами и каталогами.
  - `id` - вывод информации о пользователе и группах.
  - `/etc/passwd` - список всех пользователей.
  - `/etc/group` - список всех групп.
  - `/etc/shadow` - хранит зашифрованные пароли пользователей.

- **Права доступа**
  - `ls -l` - вывод прав доступа к файлам.
  - `-rw-rw-r--`:
    - `pos1` - тип файла:
      - `-` - обычный файл,
      - `d` - каталог,
      - `l` - символическаак ссылка.
    - `pos2-4` - права доступа владельца,
    - `pos5-7` - права доступа группы,
    - `pos8-10` - права доступа остальных пользователей:
      - `w` - запись,
      - `r` - чтение,
      - `x` - выполнение.
  - `Lrwxrwxrwx` - символическая ссылка. Все символические ссылки имеют недействительные права доступа. Фактические права доступа определяются файлом, на который ссылается символическая ссылка.

- **chmod - изменение прав доступа к файлу**
  - `chmod 777 file.txt` - **восьмеричное представление** прав доступа.
  - `chmod ugo+rwx file.txt` - **символьное представление** прав доступа.
    - `u` - владелец,
    - `g` - группа,
    - `o` - остальные пользователи,
    - `a` - все пользователи (синоним `ugo`, для краткости).
  - **Символьное представление удобно тем, что позволяет установить единственный атрибут, не затрагивая остальные.**
  - `chmod +x file.txt` - добавление права выполнения. Эквивалентно `chmod a+x file.txt`.
  - `chmod u+x,go=rx file.txt` - Добавляет право на выполнение для владельца и устанавливает право на чтение и выполнение для группы и всего мира.

- **umask - определение разрешений доступа к файлам по умолчанию**
  - Работают в момент создания файла.
  - Маска - это восьмеричное число, которое применяется к правам доступа по умолчанию. Маска вычитается из режима доступа, установленного при создании файла, т.е. `umask 022` означает, что установлены права доступа `rw-r--r--`. Т.е. там где `umask` равен `1` права будут удаляться.
  - По дефолту `umask` равен `0002`.

- **Приобретение идентичности другого пользователя**
  - Чаще всего требуется для выполнения команд от имени суперпользователя.
  - Но так же можно использовать для выполнения команд от имени другого обычного пользователя.
  - **`su` - смена пользователя**.
    - `su -` - смена пользователя на суперпользователя.
    - `su user` - смена пользователя на `user`.
    - `su -l user` - смена пользователя на `user` с загрузкой его окружения.
    - `su -c 'command' user` - выполнение команды от имени `user`.
  - **`sudo` - выполнение команды от имени суперпользователя**.
    - Администратор может определить, какие команды и какие пользователи могут использовать `sudo`. Может быть разрешен доступ только к определенным командам.
    - `sudo` продолжает доверять пользователю в течении нескольких минут после первой команды.
    - `sudo` не запускает новую оболочку(и не загружает окружение другого пользователя), а `su` запускает.
    - `sudo -l` - вывод списка команд, которые можно выполнить от имени суперпользователя.

- **chown - изменение владельца и группы файла**
  - Для использование этой команда необходимы права суперпользователя.
  - `chown user:group file.txt` - изменение владельца и группы файла.
  - `chown user file.txt` - изменение владельца файла.
  - `chown :group file.txt` - изменение группы файла.

- **chmod g+s**
  - Это полезно для управления доступом к файлам в совместно используемых каталогах, так как все новые файлы и подкаталоги будут принадлежать одной группе, даже если их создают разные пользователи.
  - `chmod g+s`: Эта команда устанавливает бит `setgid` (Set Group ID) на указанный каталог.
  - `setgid` на каталоге означает, что любые новые файлы или каталоги, созданные в этом каталоге, будут наследовать группу владельца родительского каталога

- **Изменение пароля**
  - `passwd` - изменение своего пароля.
  - `passwd user` - изменение пароля указанного пользователя.

### Глава 10. Процессы

- **Термины**
  - В момент **запуска системы** ядро инициирует выполнение нескольких собственных задач в виде процессов и запускает программу с названием `init`.
  - `init` запускает сценарии начальной загрузки (**init scripts**), которые запускают все системные службы.
  - Службы реализованы в виде демонов (**daemons**) - процессов, которые работают без участия пользователя.
  - Принцип по которому программа может запускать другие программы, выражается правилом: **родительский процесс запускает дочерний процесс**.
  - Процессы имеют **идентификатор процесса (PID)** и **идентификатор владельца и пользователя (UID)**.

- **ps - вывод списка процессов**
  - `ps` - вывод списка процессов.
  - `ps x` - вывод всех процессов, независимо от того, связаны ли они с текущим сеансом. Знак `?` в столбце `TTY` означает, что процесс не связан с терминалом.
  - Состояния процессов:
    - `R` - выполняется,
    - `S` - ожидает ввода,
    - `D` - ожидает ввода/вывода,
    - `Z` - зомби,
    - `T` - остановлен,
    - `<` - высокий приоритет,
    - `N` - низкий приоритет.
  - `ps aux` - вывод всех процессов в системе.
    - `a` - вывод процессов всех пользователей.
    - `u` - вывод дополнительной информации о процессах.
    - `x` - вывод процессов, не связанных с терминалом.
    - `VSZ` - размер виртуальной памяти процесса.
    - `RSS` - размер физической памяти процесса.

- **top - просмотр состояния процессов в динамике**
  - `top` - вывод списка процессов в динамике.
  - `q` - выход.
  - `h` - справка.
  - `k` - завершение процесса.

- **Управлнеие процессами**
  - `Ctrl+C` - прерывание процесса.
  - Фоновые процессы еще называются **заданиями**.
  - `process &` - запуск процесса в фоне (задание).
  - `jobs` - вывод списка процессов в фоне (заданий).
  - `fg %1` - перевод процесса в передний план. `%1` - номер процесса (задания).
  - `Ctrl+Z` - приостановка процесса.
    - Процесс переходит в состояние `S` (Stopped).
    - Чтобы возобновить процесс, используйте `fg`.

- **Сигналы**
  - Это один из способов, которым ОС общается с процессами.
  - `kill <PID>` - отправка сигнала процессу.
    - Требуются права суперпользователя, чтобы посылать сигналы процессам, которыми вы не владеете.
    - **`kill -l` - вывод списка сигналов**.
    - `kill -HUP <PID>` - перезапуск процесс (сигнал обрыва связи). Номер сигнала `1`.
    - `kill -INT <PID>` - прерывание процесса. Номер сигнала `2`.
    - `kill -KILL <PID>` - жесткое завершение процесса. Номер сигнала `9`. Ядро немедленно завершает процесс.
    - `kill -TERM <PID>` - завершение процесса. Номер сигнала `15`. Процесс может обработать этот сигнал и завершиться корректно.
    - `kill -CONT <PID>` - возобновление процесса после сигнала `STOP`.
    - `kill -STOP <PID>` - приостановка процесса.
  - **`killall <name>` - отправка сигнала всем процессам с указанным именем**.
    - `killall [-u user] [-SIGNAL] processname` - отправка сигнала всем процессам с указанным именем, принадлежащим указанному пользователю.

- **Информация по процессам и аналитика**
  - `pstree` - вывод дерева процессов.
  - `vmstat` - вывод статистики виртуальной памяти.
  - `xload` - вывод графика загрузки процессора в X Window.
  - `tload` - вывод графика загрузки процессора в текстовом режиме.

## Часть II. Окружение и настройка

Использование окруженния дла настройки некоторых параметров командной оболочки.

### Глава 11. Окружение

- **Что хранит командная оболочка**
  - Переменные окружения - переменные, которые доступны всем процессам, запущенным в текущем окружении.
  - Переменные оболочки - переменные, доступные только оболочке.
    - Программируемые данные
      - Псевдонимы(`alias`) - псевдонимы команд.
      - Функции оболочки(`function`) - мини-сценарии, встроенные в окружение.

- **Вывод переменных**
  - `set` - вывод всех переменных окружения и оболочки.
  - `printenv` - вывод переменных окружения.
  - `printenv USER` - вывод значения переменной окружения.
  - `echo $USER` - вывод значения переменной оболочки.
  - `alias` - вывод всех псевдонимов.

- **Как загружается командная оболочка**
  - Читает файлы настроек при запуске.
  - Наследует переменные окружения от родительского процесса.
  - `export PATH` - экспорт переменной окружения. Делает содержимое переменной доступным для дочерних процессов.
  - `source ~/.bashrc` - заставляет оболочку перечитать файл настроек.
  - Если вы не системный администратор, то вам доступны изменения только в файлах домашнего каталога.
  - **Login** shell session - оболочка, которая запускается при входе в систему.
    - `/etc/profile` - общие настройки для всех пользователей.
    - `~/.bash_profile` - настройки для конкретного пользователя. Для расширения и/или переопределения общих настроек.
    - `~/.bash_login` - настройки для конкретного пользователя.
    - `~/.profile` - если нет `~/.bash_profile` и `~/.bash_login`.
  - **Non-login** shell session - оболочка, которая запускается внутри графической среды.
    - `/etc/bash.bashrc` - общие настройки для всех пользователей.
    - `~/.bashrc` - настройки для конкретного пользователя. Для расширения и/или переопределения общих настроек.
      - `export HISTCONTROL=ignoredups` - игнорирование дубликатов в истории команд.

- **Редакторы текстовых файлов**
  - С графическим интерфейсом: `gedit`, `kate`, `kwrite`.
  - Без графического интерфейса: `nano`, `vim`, `emacs`.

### Глава 12. Плавное введение в vi

- `vi filename` - запуск редактора vi. Если файл не существует, он будет создан.
- `vim filename` - запуск улучшенной версии vi.
- `vim file1 file2` - открытие нескольких файлов.

- **Режимы работы vi**
  - **Командный режим** - режим, в котором вы можете перемещаться по файлу и выполнять команды. Запускается при запуске vi.
    - `:...` - ex-команды (символ `:` начинает ex-команду).
    - `<key press>` - выполнение команды.
    - `i` - переход в режим вставки.
    - `a` - переход в режим вставки после курсора.
  - **Режим вставки** - режим, в котором вы можете вводить текст.
    - `ESC ESC` - переход в режим команд.

- **Undo/Redo**
  - `u` - отмена последнего действия.
- **Перемещение**
  - `Стрелки` - перемещение курсора.
  - `0` - перемещение к началу строки.
  - `$` - перемещение к концу строки.
  - `w` - перемещение к следующему слову.
  - `b` - перемещение к предыдущему слову.
  - `12G` - перемещение к 12 строке.
- **Добавление**
  - `o` - добавление новой строки ниже и переход в режим вставки.
  - `O` - добавление новой строки выше и переход в режим вставки.
- **Удаление**
  - `x` - удаление символа под курсором.
  - `dd`, `5dd` - удаление строки, удаление 5 строк.
  - `dw`, `5dw` - удаление слова, удаление 5 слов.
  - `d$` - удаление до конца строки.
  - `d^` - удаление от текущей позиции до начала строки.
  - `J` - объединение текущей строки со следующей (удаление конца строки).
- **Поиск**
  - `f<char>` - поиск символа в строке.
  - `/pattern` - поиск шаблона в файле.
  - `:%s/pattern/replacement/g` - замена шаблона во всем файле.
  - `:1,5s/pattern/replacement/g` - замена шаблона в диапазоне строк c 1 по 5.
  - `:1,5s/pattern/replacement` - поиск и замена только первого вхождения в каждой с 1 по 5 строке.
  - `:1,5s/pattern/replacement/c` - ... еще запрашивать подтверждение.
- **Копирование**
  - `yy`, `5yy` - копирование строки, копирование 5 строк.
  - `p` - вставка скопированного текста.
  - `:r filename` - вставка содержимого файла в текущую позицию (по сути копирование).
  - `Yp` - дублирование строки.
- **Работа с файлами**
  - `:q` - выход.
  - `:q!` - выход без сохранения.
  - `:w` - сохранение.
  - `ZZ` - сохранение всех файлов и выход.
  - `:e filename` - открытие файла.
  - `:buffers`, `:ls` - вывод списка редактируемых файлов.
  - `:bn`, `:bp`, `:b<number>` - переключение между файлами.

### Глава 13. Настройка приглашения к вводу

- `echo $PS1` - переменная, содержащая строку приглашения к вводу.
- `ps1_old=$PS1` - сохранение текущего значения переменной.
- `$PS1="new prompt"` - изменение значения переменной.
- `vi ~/.bashrc` - настройка находится тут. У меня получилось изменить цвет приглашения к вводу через редактирование файла. Потом надо сделать `source ~/.bashrc`.

## Часть III. Типичные задачи и основные инструменты

### Глава 14. Управление пакетами

- **Package management** - это методика установки и управления программным обеспечением в системе.
  - В первые года развития Linux для установки программ требовалось скачивать и **компилировать исходный код**.
  - Пакеты между различными дистрибутивами несовместимы.
  - **Файл пакета** - это архив, содержащий программу и метаданные о ней.
  - Готовые пакеты помещаются в ценральный **репозиторий** дистрибутива.
  - Дистрибутивы обычно имеют тестовые и стабильные репозитории.
  - Драйверы устройств распространяются почти также как и программы, только они не выделяются в репозитории дистрибутива, а включаются в ядро.

- **Инструменты управления пакетами**
  - **Низкоуровневые** - устанавливают пакеты напрямую.
    - **`dpkg`** - Debian, Ubuntu.
    - **`rpm`** - Red Hat, Fedora.
    - **`rpm2cpio`** - конвертация rpm в cpio.
    - **`cpio`** - утилита для работы с архивами.
  - **Высокоуровневые** - устанавливают пакеты и их **зависимости**.
    - **`apt`** - Debian, Ubuntu.
    - **`yum`** - Red Hat, Fedora.
    - **`zypper`** - OpenSUSE.

- **Низкоуровневые команды**
  - `dpkg -i package.deb` - установка/обновление пакета.
  - `dpkg --list` - вывод списка установленных пакетов.
  - `dpkg --status package` - вывод информации о пакете.
  - `dpkg --search file` - поиск пакета по установленному файлу.

- **Команды для работы с репозиторием**
  - `apt-get update` - обновление списка пакетов.
  - `apt-get upgrade` - обновление всех пакетов.
  - `apt-cache search pattern` - поиск пакета.
  - `apt-cache show package` - вывод информации о пакете.
  - `apt-get install package` - установка пакета.
  - `apt-get remove package` - удаление пакета.

### Глава 15. Устройства хранения

- **Монтирование**
  - Монтирование - подключение самого устройства к дереву файловой системы.
  - Unix-подобные операционные системы поддериживают единое дерево файловой системы, к разным точкам которого подключаются дополнительные устройства. Этот подход отличается от Windows, где каждое устройство имеет свое собственное дерево файлов.
  - Файл `/etc/fstab` содержит информацию о том, какие устройства монтируются при загрузке системы.
  - `mount` - вывод списка подключенных устройств. Там не только устройства хранения, но и многое другое.
  - `umount` - отключение устройства. Размонтирование устройства влечет за собой запись всех оставшихся данных в это устройство, чтобы его можно было безопасно извлеч.
  - Процесс размонтирования и повторного монтирования.
    - `umount /dev/sdb1` - размонтирование устройства.
    - `mount /dev/sdb1 /mnt` - монтирование устройства.

- **Определение названий устройств**
  - `ls /dev` - вывод списка устройств.
    - `/dev/fd*` - дискеты.
    - `/dev/hd*` - IDE-устройства.
    - `/dev/sd*` - SCSI-устройства (включая USB-устройства).
    - `/dev/sr*` - CD/DVD-устройства.
  - `sudo tail -f /var/log/syslog` - вывод логов ядра. **Можно увидеть какие устройства подключаются и какие имена им присваиваются**.
    - `kubuntu kernel:  sda: sda1`
      - `sda` - физическое устройство.
      - `sda1` - раздел на устройстве.
    - Затем можно сделать монтирование: `mount /dev/sda1 /mnt`.

- **Управление разделами диска (fdisk)**
  - `sudo fdisk /dev/sda` - запуск утилиты для управления разделами диска.
    - `p` - вывод таблицы разделов.
    - `n` - создание нового раздела.
    - `d` - удаление раздела.
    - `w` - запись изменений.
    - `q` - выход без сохранения.
    - `t` - изменение типа раздела: `83` - Linux, `82` - Linux swap.

- **Управление файловыми системами**
  - `sudo mkfs -t ext4 /dev/sda1` - создание файловой системы.
  - `sudo fsck /dev/sda1` - проверка файловой системы.
    - Перед запуском `fsck` необходимо размонтировать файловую систему.
    - Может восстановить поврежденные фрагменты файлов. Они будут помещены в каталог `lost+found`.

- **Создание копии диска**
  - `dd` - утилита, которая делает низкоуровневую копию данных, т.к. копирует блоки данных, а не файлы.
  - `sudo dd if=/dev/sda of=/dev/sdb` - копирование всего диска между устройствами.
  - `sudo dd if=/dev/sda of=~/disk.img` - копирование всего диска в файл.
  - `md5sum /dev/sda` - вычисление контрольной суммы диска.

### Глава 16. Сети

- **Исследование и мониторинг сети**
  - `ping google.com` - **проверка доступности хоста**.
    - Большинство сетевых устройств принимает эти пакеты(пакеты ICMP Echo Request) и отправляет обратно пакеты с ответом(пакеты ICMP Echo Reply).
    - Для повышения безопасности сетевые устройства могут блокировать ICMP-пакеты.
  - `traceroute google.com` - **определение маршрута пакетов**.
    - Показывает все узлы, через которые проходят пакеты.
    - Для маршрутизаторов, которые блокируют ICMP-пакеты выводится `* * *`.
  - **Вывод параметров настройки сети**
  - `netstat -ie` - вывод информации о сетевых интерфейсах.
  - `netstat -r` - вывод таблицы маршрутизации.

- **Передача файлов по сети**
  - **Небезопасные(нешифрованные) взаимодействия**
    - `ftp ftp.gnu.org` - подключение к FTP-серверу.
      - `Name (ftp.gnu.org:sergey): anonymous` - ввод логина. Анонимный доступ позволяет войти без пароля.
      - `cd /pub/gnu` - переход в каталог.
      - `ls` - вывод списка файлов.
      - `get file` - скачивание файла.
      - `put file` - загрузка файла.
      - `bye` - выход.
    - `lftp ftp.gnu.org` - улучшенный FTP-клиент.
      - Поддерживает восстановление загрузки файлов.
      - Поддерживает фоновую загрузку файлов.
    - `wget http://www.gnu.org/software/bash/manual/bash.pdf` - загрузка файла по HTTP.
  - **Безопасные взаимодейтвия**
    - `OpenSSH-server` - устанавливается на сервере, чтобы позволить клиентам подключаться к нему.
    - `OpenSSH-client` - устанавливается на клиенте, чтобы позволить подключаться к серверу.
    - **ssh**
      - `ssh user@hostname` - подключение к удаленному хосту под пользователем `user`.
      - `ssh hostname` - подключение к удаленному хосту под текущим пользователем.
      - При установлении подключения будет выведена строка про finferprint ключа.
        - Это значит, что ключ сервера неизвестен. Либо это вы впервые подключаетесь к серверу, либо атака Man-in-the-middle.
        - Важная строка в вываде: `Offending key in /home/sergey/.ssh/known_hosts:1` - указывает на конкртный ключ в файле, который вызвал ошибку.
      - `ssh remotehost command` - выполнение одиночной команды на удаленном хосте:
        - `ssh remotehost 'ls *'` - кавычки показывают границы команды.
      - `ssh -X user@hostname` - подключение с возможностью получения изображений рабочего стола.
    - **scp и sftp**
      - `scp file user@hostname:/path` - копирование файла на удаленный хост.
      - `scp user@hostname:/path/file .` - копирование файла с удаленного хоста.
      - `sfpt user@hostname` - подключение к удаленному хосту по SFTP.

### Глава 17. Поиск файлов

- **`locate file` - поиск файла в базе данных имен файлов**
  - `updatedb` - обновление базы данных. Это обновление происходит автоматически раз в день (cron).
  - `locate file | grep pattern` - поиск файла по шаблону.
- **`find` - сложный поиск файлов**
  - `find / -name file` - поиск файла по имени.
  - `find / | wc -l` - подсчет количества файлов.
  - `find / -type f -size +100M` - поиск файлов размером более 100Мб.
  - Важно не забывать кавычки, чтобы не дать оболочке интерпретировать шаблоны: `find / -name '*.txt'`.

- **Проверки для `find`** - проверки валидируют подходит ли файл под условие.
  - `-name` - поддеоживает шаблоны: `*` - любое количество символов, `?` - один символ.
  - `-type`: `b` - блочный файл, `c` - символьный файл, `d` - каталог, `l` - символьная ссылка, `p` - именованный канал, `s` - сокет.
  - `-size`: `+` - больше, `-` - меньше, `=` - равно.
    - units: `c` - байты, `k` - килобайты, `M` - мегабайты, `G` - гигабайты.
  - `-nouser`, `-nogroup` - поиск файлов без владельца. Подходит для обнаружения следов злоумышленников.
  - `-mtime`, `-atime`, `-ctime` - поиск файлов по времени модификации, доступа, изменения.
  - `-newer file` - поиск файлов, измененных после указанного файла.
  - `-perm` - поиск файлов по правам доступа.
  - `-samefile file` - поиск файлов, которые являются символьными ссылками на указанный файл.
- **Операторы для `find`** - позволяют объединять проверки.
  - `-and` - логическое И. По умолчанию все проверки объединяются логическим И.
    - Если первая проверка возвращает `false`, то вторая проверка не выполняется.
  - `-or` - логическое ИЛИ.
    - Если первая проверка возвращает `true`, то вторая проверка не выполняется.
  - `-not` - логическое НЕ. Пример: `find / -not -name '*.txt'`.
  - `( ... )` - группировка проверок.
  - `find ~ -name '*.txt' -or -name '*.md'`.
- **Операции для `find`**
  - `find ~ -name '*.pdf' -or -name '*.md' -and -size +200k -ok head {} \;`
  - `find ~ -name '*.pdf' -or -name '*.md' -and -size +200k -ok ls -l {} \;`
  - `-ok` - запрос на подтверждение перед выполнением команды.
  - `-delete` - удаление найденных файлов.
  - `-ls` - вывод информации о найденных файлах.
  - `-print` - вывод пути к найденным файлам. Выполняется по умолчанию.
  - `-quit` - завершение поиска после первого найденного файла.
  - **`-exec command {} \;`** - выполнение команды над найденным файлом.
    - `find ~ -name '*.pdf' -or -name '*.md' -and -size +200k -exec ls -l {} +`   - выполнение команды над всеми найденными файлами.
    - `find ~ -name '*.pdf' -or -name '*.md' -and -size +200k -exec ls -l {} \;`  - выполнение команды над каждым найденным файлом.
    - `{}` - это плейсхолдер, который заменяется на имя файла.
    - `find / -name '*.txt' -exec cp {} /tmp \;` - копирование всех файлов с расширением `.txt` в `/tmp`.
    - `-ok command {} \;` - запрос на подтверждение перед выполнением команды.
  - **`xargs`** - принимает входные данные со стандартного ввода и преобразует из в список аргументов для указанной команды
    - По сути это альтернатива `-exec command {} +`, которая так же позволяет обрабатывать большое количество файлов за один раз.
    - Но я так понял, что `xargs` может принимать не долько файлы, но и другие данные.
    - Когда длина командной строки превышает максимальное значение, `xargs` разбивает список на несколько частей и вызывает команду несколько раз.
    - `find ~ -name '*.txt' | xargs ls -l` - вывод информации о найденных файлах.
- **Параметры `find`**
  - `-depth` - сначала обрабатываются дочерние элементы, затем родительские.
    - Этот параметр по дефолту применяется с командой `-delete`.
    - `find / -depth -name '*.txt'`.
  - `-maxdepth` - ограничение глубины поиска.
    - `find / -maxdepth 2 -name '*.txt'`.
  - `-mindepth` - минимальная глубина поиска.
    - `find / -mindepth 2 -name '*.txt'`.
  - `-mount` - не выполнять поиск в других файловых системах.
    - `find / -mount -name '*.txt'`.
  - `-noleaf` - не использовать оптимизацию поиска, опираясь на предположение, что ведется поиск в Unix-подобной файловой системе.
    - `find / -noleaf -name '*.txt'`.

- **Создание печочницы из файлов для экспериментов**
  - `mkdir -p playground/dir-{00{1..9},0{10..99},100}` - создание директорий.
  - `touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}` - создание файлов.
  - `touch` - создание пустого файла, либо обновление времени последнего доступа существующего файла.
  - `stat file` - вывод информации о файле.
  - `find -name "file-O" | grep *005 | xargs stat` - поиск файла по имени, затем фильтр по пути, затем вывод информации о файле.

### Глава 18. Архивация и резервное копирование

- **Сжатие файлов**
  - **C потерями (lossy)**
    - JPEG - сжатие изображений.
    - MP3 - сжатие аудио.
  - **Без потерь (lossless)**
    - Кодирование длин серий (RLE) - кодирование последовательностей одинаковых символов.

- **gzip** - **сжатие и распаковка** файлов
  - `gzip file` - сжатие файла. Старый файл удаляется.
  - `gzip -k file` - сжатие файла. Старый файл остается.
  - `gzip -r dir` - сжатие директории, причем сжимаются все файлы внутри, но не сама директория.
    - `find . -name '*.gz' -exec gzip -d {} \;` - распаковка всех файлов в директории рекурсивно.
  - `gzip -d file.gz` или `gunzip file.gz` - распаковка файла.
  - `gzip -f file` - сжатие файла с заменой существующего архива.
  - `gzip -c file` - вывод сжатого файла в стандартный вывод.
  - `gzip -v file` - вывод информации о сжатии.

- **bzip2** - сжатие и распаковка файлов с более высоким коэффициентом сжатия

- **tar** - утилита для **архивирования** файлов (без сжатия)
  - `tar -cvf archive.tar file1 file2` - создание архива.
    - `c` - создание архива.
    - `v` - вывод списка файлов.
    - `f` - указание имени архива.
  - `tar -xvf archive.tar` - распаковка архива.
    - `x` - распаковка архива.
    - По умолчанию внутри используются относительные пути. Поэтому вы можете распаковать архив в любую директорию с сохранением структуры.
    - Вам нужно быть суперпользователем, для того чтобы сохранить владельца и группу.
  - `tar --wildcards -xvf archive.tar '*.txt'` - распаковка файлов по шаблону.
  - `find playground -name 'file-A' -exec tar -rvf archive.tar {} +` - добавление файлов в архив по шаблону.
    - Можно использовать find для поиска файлов изменных за последние 7 дней и добавить их в архив. Таким образом можно получить инкрементальное резервное копирование.
  - **`find playground -name 'file-A' | tar cf - --files-from=- | gzip > playground.tgz` - работа через пайпы**
    - `cf -` - вывод архива в стандартный вывод, этот ввод передается в gzip.
    - `--files-from=-` - чтение списка файлов из стандартного ввода.
  - `ssh user@host 'tar cf - Documents' | tar xf -` - передача сжатых файлов по ssh и их распаковка.
    - `xf -` - чтение архива из стандартного ввода и распаковка.

- **zip** - **упаковка и сжатие** файлов
  - `zip -r archive.zip dir` - создание архива.
  - `unzip -l archive.zip` - вывод списка файлов в архиве без распаковки.
    - `-l` - вывод списка файлов.
    - `-v` - вывод подробной информации о каждом файле.
  - `unzip archive.zip` - распаковка архива.
  - `find playground -name "file-A" | zip -@ file-A.zip` - создание архива из файлов по шаблону через пайпы.
    - `-@` - чтение списка файлов из стандартного ввода.
  - `ls -l playground | zip playground2.zip -` - создание архива из файлов в директории.
  - `-` - чтение списка файлов из стандартного ввода.
  - `upzip -p archive.zip` - вывод содержимого архива в стандартный вывод.

- **rsync** - **синхронизация файлов и каталогов** (поддеоживает удаленные системы)
  - Позволяет быстро обнаруживать различия между двумя каталогами и копировать только измененные данные (миниальный объем информации).
  - Копирование из удаленной системы в удаленную систему не поддерживается.
  - `rsync -av playground playground2` - синхронизация двух директорий.
  - `sudo rsync -avz --delete --rsh=ssh /etc /home /usr/local user@host:/backup` - резервное копирование системных файлов на удаленный хост.
    - `a` - архивный режим. Копирование файлов рекурсивно, сохранение прав доступа, времени модификации и других атрибутов.
    - `v` - вывод информации о процессе.
    - `z` - сжатие данных.
    - `--rsh=ssh` - использование ssh для передачи данных.
    - `--delete` - удаление файлов на удаленном хосте, которых нет на локальном.
  - `rsync -av -delete rsync://rsync.gtlib.gatech.edu/dir1/dir2/file` - синхронизация с удаленным репозиторием.
    - `rsync://rsync.gtlib.gatech.edu/dir1/dir2/file` - адрес удаленного репозитория.
    - `fedora-devel` - локальная директория.

### Глава 19. Регулярные выражения

- Регулярные выражения - это всего лишь символическая форма записи, используемая для идентификации шаблонов в тексте.
- `grep` = Global Regular Expression Print

- **Типы регулярных выражений**
  - BRE - **Basic Regular Expressions**.
    - Поддерживаются стандартом POSIX.
  - ERE - **Extended Regular Expressions**.
    - Поддерживаются в `grep -E`.
    - Включают в себя дополнительные метасимволы: `+`, `?`, `|`, `()`, `{}`.

- **Метасимволы для регулярных выражений**
  - `.` - один любой символ.
  - `^` - начало строки.
  - `$` - конец строки.
  - `*` - ноль или более вхождений предыдущего символа.
  - `+` - одно или более вхождений предыдущего символа.
  - `[]` - один из символов в скобках.
  - `[^]` - один из символов не в скобках.
  - `()` - группировка символов.
  - `\` - экранирование метасимволов.
  - `|` - логическое ИЛИ.
  - `{n}` - n вхождений предыдущего символа.
  - `{n,}` - n или более вхождений предыдущего символа.
  - `{n,m}` - от n до m вхождений предыдущего символа.
  - `[a-z]` - один символ из диапазона.

- **Классы символов для регулярных выражений**
  - `[[:word:]]` - буквы, цифры и знак подчеркивания.
  - `[[:alnum:]]` - буквы и цифры.
  - `[[:alpha:]]` - буквы.
  - `[[:digit:]]` - цифры.
  - `[[:lower:]]` - строчные буквы.
  - `[[:upper:]]` - заглавные буквы.
  - `[[:space:]]` - пробельные символы.
  - `[[:punct:]]` - знаки пунктуации.
  - `[[:print:]]` - печатаемые символы.
  - `[[:graph:]]` - печатаемые символы без пробелов.

- **Поиск в тексте(grep) - BRE**
  - `grep params pattern file` - поиск шаблона в файле.
  - `grep bzip dirlist*.txt` - поиск слова `bzip` в файлах.
  - `grep -l bzip dirlist*.txt` - вывод имен файлов, где найдено слово `bzip`.
    - `-i` - игнорирование регистра.
    - `-v` - вывод строк, не содержащих шаблон.
    - `-n` - вывод номера строки.
    - `-c` - вывод числа совпавших строк.
    - `-l` - вывод только имен файлов, где найден шаблон.
    - `-L` - вывод только имен файлов, где не найден шаблон.
    - `-h` - подавление вывода имен файлов при поиске в нескольких файлах.
  - **Использование регулярных выражений с grep**
    - `grep -h ^zip dirlist*` - вывод строк, начинающихся с `zip`.
    - `grep -h zip$ dirlist*` - вывод строк, заканчивающихся на `zip`.
    - `grep -h ^[0-9] dirlist*` - вывод строк, начинающихся с цифры.
    - `grep -h ^[^0-9] dirlist*` - вывод строк, начинающихся не с цифры.
    - `grep -h ^[abc] dirlist*` - вывод строк, начинающихся с `a`, `b`, `c`.
    - `grep -h 'a\{2\}' dirlist*` - вывод строк, содержащих два символа `a` подряд. **Обратите внимание на экранирование фигурных скобок. Оно необходимо, чтобы оболочка не интерпретировала их как часть синтаксиса оболочки.**
  - **Использование классов символов в регулярных выражениях**
    - `grep -h '[[:digit:]]' dirlist*` - вывод строк, содержащих цифры.

- **egrep** - **расширенный grep с поддержкой ERE**
  - `grep -E` - аналог `egrep`.
  - `grep -Eh '^(bz|gz|zip)' dirlist*.txt` - вывод строк, начинающихся с `bz`, `gz`, `zip`.
  - `echo "(555) 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'` - поиск телефонного номера.
    - `?` - ноль или одно вхождение предыдущего символа.
    - `\(` - экранирование скобки.

- **Примеры использования регулярок для grep, find, locate**
  - `for i in {1..10}; do echo "(${RANDOM:0:3}) ${RANDOM:0:3}-${RANDOM:0:4}" >> phonelist.txt; done` - генерация телефонных номеров.
    - `grep -Evn '\([0-9]{3}\) [0-9]{3}-[0-9]{4}' phonelist.txt` - поиск плохих номеров и вывод их номеров строк.
  - `find . -regex '.*\(\.txt\|\.md\)$'` - поиск файлов с расширениями `.txt` и `.md`.
  - `locate --regex 'bin/(bz|gz|zip)'` - поиск файлов в директории `bin` с расширениями `bz`, `gz`, `zip`.
  - `zgrep -El 'regex|regular expression' *.gz` - поиск в архивированных файлах. Запустите поиск в папке `cd /usr/share/man/man1`.
  - `less` и
  - `vim` - имеют встроенную поддержку регулярных выражений (vim поддерживает только BRE).
    - `/pattern` - поиск шаблона в тексте.
    - `n` - следующее вхождение.
    - `N` - предыдущее вхождение.
    - `?pattern` - поиск назад.
    - `q` - выход.

### Глава 20. Обработка текста

### Глава 21. Форматирование вывода

### Глава 22. Печать

### Глава 23. Компиляция программ

## Часть IV. Сценарии командной оболочки

### Глава 24. Создание первого сценария командной оболочки

### Глава 25. Начало проекта

### Глава 26. Проектирование сверху вниз

### Глава 27. Управление потоком выполнения: ветвление при помощи if

### Глава 28. Чтение ввода с клавиатуры

### Глава 29. Управление потоком выполнения: циклы while и until

### Глава 30. Поиск и устранение ошибок

### Глава 31. Управление потоком выполнения: ветвление с помощью case

### Глава 32. Позиционные параметры

### Глава 33. Управление потоком выполнения: цикл for

### Глава 34. Строки и числа

### Глава 35. Массивы

### Глава 36. Экзотика
