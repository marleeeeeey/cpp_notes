# William Shotts - The Linux Command Line

- [Часть I. Командная оболочка](#часть-i-командная-оболочка)
  - [Глава 1. Что такое командная оболочка](#глава-1-что-такое-командная-оболочка)
    - [Основные клавиши и команды `date`, `cal`, `df`, `free`, `exit`](#основные-клавиши-и-команды-date-cal-df-free-exit)
  - [Глава 2. Навигация](#глава-2-навигация)
    - [Команды `pwd`, `ls`, `cd`](#команды-pwd-ls-cd)
  - [Глава 3. Исследование системы](#глава-3-исследование-системы)
    - [Команды `ls`, `file`, `less`](#команды-ls-file-less)
    - [Мнемоника: `command -option argument`.](#мнемоника-command--option-argument)
    - [Каталоги в системе linux](#каталоги-в-системе-linux)
  - [Глава 4. Операции с файлами и каталогами](#глава-4-операции-с-файлами-и-каталогами)
    - [Команды `mkdir`, `cp`, `mv`, `rm`](#команды-mkdir-cp-mv-rm)
    - [Жесткие ссылки (`ln`)](#жесткие-ссылки-ln)
    - [Символические ссылки (`ln -s`)](#символические-ссылки-ln--s)
  - [Глава 5. Работа с командами](#глава-5-работа-с-командами)
    - [Чем могут быть команды в Linux (builtins, shell functions, aliases)](#чем-могут-быть-команды-в-linux-builtins-shell-functions-aliases)
    - [Команды `type`, `which`, `--help`, `man`, `apropos`, `whatis`, `info`](#команды-type-which---help-man-apropos-whatis-info)
    - [Разделение команд (`;`)](#разделение-команд-)
    - [Алиасы (`alias`, `unalias`)](#алиасы-alias-unalias)
  - [Глава 6. Перенаправление](#глава-6-перенаправление)
    - [Потоки (`stdin`, `stdout`, `stderr`)](#потоки-stdin-stdout-stderr)
    - [Перенаправление вывода (`>`, `>>`, `2>`, `2>&1`, `/dev/null`)](#перенаправление-вывода---2-21-devnull)
    - [Конкатенация или вывод содержимого файлов (`cat`)](#конкатенация-или-вывод-содержимого-файлов-cat)
    - [Конвейер (pipes) `cmd1 | cmd2` - стандартный вывод одной команды передается в стандартный ввод другой.](#конвейер-pipes-cmd1--cmd2---стандартный-вывод-одной-команды-передается-в-стандартный-ввод-другой)
    - [Фильтры (`sort`, `uniq`, `wc`, `grep`, `head`, `tail`, `tee`) - принимают ввод, изменяют его определенным образом и выводят результат.](#фильтры-sort-uniq-wc-grep-head-tail-tee---принимают-ввод-изменяют-его-определенным-образом-и-выводят-результат)
  - [Глава 7. Взгляд на мир глазами командной оболочки](#глава-7-взгляд-на-мир-глазами-командной-оболочки)
    - [Подстановка (\*)](#подстановка-)
    - [Подстановка путей (Pathname expansion)](#подстановка-путей-pathname-expansion)
    - [Подстановка результатов арифметических выражений `$((2 + 2))`](#подстановка-результатов-арифметических-выражений-2--2)
    - [Подстановка фигурных скобок `{}`](#подстановка-фигурных-скобок-)
    - [Подстановка переменных](#подстановка-переменных)
    - [Подстановка команд](#подстановка-команд)
    - [Экранирование](#экранирование)
    - [Двойные кавычки `"` - экранируют все символы, кроме `$`, `\` и `"`.](#двойные-кавычки----экранируют-все-символы-кроме---и-)
    - [Одинарные кавычки `'` - экранируют все символы.](#одинарные-кавычки----экранируют-все-символы)
    - [Экранирование одного символа](#экранирование-одного-символа)
  - [Глава 8. Продвинутые приемы работы с клавиатурой](#глава-8-продвинутые-приемы-работы-с-клавиатурой)
    - [Цели командной строки](#цели-командной-строки)
    - [Полезные для меня сочетания клавиатуры](#полезные-для-меня-сочетания-клавиатуры)
    - [История команд (`history`, `.bash_history`, `Ctrl+R`)](#история-команд-history-bash_history-ctrlr)
  - [Глава 9. Привилегии](#глава-9-привилегии)
    - [Владение файлами и каталогами (`id`, `/etc/passwd`, `/etc/group`, `/etc/shadow`)](#владение-файлами-и-каталогами-id-etcpasswd-etcgroup-etcshadow)
    - [Права доступа (`Lrwxrwxrwx`)](#права-доступа-lrwxrwxrwx)
    - [`chmod` - изменение прав доступа к файлу (`chmod 777 file.txt`)](#chmod---изменение-прав-доступа-к-файлу-chmod-777-filetxt)
    - [`umask` - определение разрешений доступа к файлам по умолчанию](#umask---определение-разрешений-доступа-к-файлам-по-умолчанию)
    - [Приобретение идентичности другого пользователя (`su`, `sudo`)](#приобретение-идентичности-другого-пользователя-su-sudo)
    - [Изменение владельца и группы файла (`chown`)](#изменение-владельца-и-группы-файла-chown)
    - [`chmod g+s` и `setgid`](#chmod-gs-и-setgid)
    - [Изменение пароля (`passwd`)](#изменение-пароля-passwd)
  - [Глава 10. Процессы](#глава-10-процессы)
    - [Термины (процесс, PID, UID, daemon)](#термины-процесс-pid-uid-daemon)
    - [`ps` - вывод списка процессов](#ps---вывод-списка-процессов)
    - [`top` - просмотр состояния процессов в динамике](#top---просмотр-состояния-процессов-в-динамике)
    - [Управлнеие процессами (`jobs`, `fg`, `bg`, `Ctrl+C`, `Ctrl+Z`)](#управлнеие-процессами-jobs-fg-bg-ctrlc-ctrlz)
    - [Сигналы (`kill`, `killall`, `kill -l`)](#сигналы-kill-killall-kill--l)
    - [Информация по процессам и аналитика (`pstree`, `vmstat`, `xload`, `tload`)](#информация-по-процессам-и-аналитика-pstree-vmstat-xload-tload)
- [Часть II. Окружение и настройка](#часть-ii-окружение-и-настройка)
  - [Глава 11. Окружение](#глава-11-окружение)
    - [Что хранит командная оболочка](#что-хранит-командная-оболочка)
    - [Вывод переменных окружения и оболочки (`set`, `printenv`, `alias`)](#вывод-переменных-окружения-и-оболочки-set-printenv-alias)
    - [Как загружается командная оболочка](#как-загружается-командная-оболочка)
    - [Редакторы текстовых файлов](#редакторы-текстовых-файлов)
  - [Глава 12. Плавное введение в vi](#глава-12-плавное-введение-в-vi)
    - [Режимы работы vi (командный, вставки)](#режимы-работы-vi-командный-вставки)
    - [Undo/Redo](#undoredo)
    - [Перемещение](#перемещение)
    - [Добавление](#добавление)
    - [Удаление](#удаление)
    - [Поиск](#поиск)
    - [Копирование](#копирование)
    - [Работа с файлами](#работа-с-файлами)
  - [Глава 13. Настройка приглашения к вводу](#глава-13-настройка-приглашения-к-вводу)
- [Часть III. Типичные задачи и основные инструменты](#часть-iii-типичные-задачи-и-основные-инструменты)
  - [Глава 14. Управление пакетами](#глава-14-управление-пакетами)
    - [Package management - это методика установки и управления программным обеспечением в системе.](#package-management---это-методика-установки-и-управления-программным-обеспечением-в-системе)
    - [Инструменты управления пакетами (`dpkg`, `rpm`, `apt`, `yum`, `zypper`)](#инструменты-управления-пакетами-dpkg-rpm-apt-yum-zypper)
    - [Низкоуровневые команды (`dpkg -i`)](#низкоуровневые-команды-dpkg--i)
    - [Команды для работы с репозиторием (`apt-get ...`)](#команды-для-работы-с-репозиторием-apt-get-)
  - [Глава 15. Устройства хранения](#глава-15-устройства-хранения)
    - [Монтирование (`mount`, `umount`)](#монтирование-mount-umount)
    - [Определение названий устройств (`ls /dev`, `/var/log/syslog`)](#определение-названий-устройств-ls-dev-varlogsyslog)
    - [Управление разделами диска (`fdisk`)](#управление-разделами-диска-fdisk)
    - [Управление файловыми системами (`mkfs`, `fsck`)](#управление-файловыми-системами-mkfs-fsck)
    - [Создание копии диска (`dd`, `md5sum`)](#создание-копии-диска-dd-md5sum)
  - [Глава 16. Сети](#глава-16-сети)
    - [Исследование и мониторинг сети (`ping`, `traceroute`, `netstat`)](#исследование-и-мониторинг-сети-ping-traceroute-netstat)
    - [Передача файлов по сети (`ftp`, `lftp`, `wget`, `ssh`, `scp`, `sftp`)](#передача-файлов-по-сети-ftp-lftp-wget-ssh-scp-sftp)
  - [Глава 17. Поиск файлов](#глава-17-поиск-файлов)
    - [`locate file` - поиск файла в базе данных имен файлов](#locate-file---поиск-файла-в-базе-данных-имен-файлов)
    - [`find` - сложный поиск файлов](#find---сложный-поиск-файлов)
    - [Проверки для `find` - проверки валидируют подходит ли файл под условие поиска (`-name`, `-type`, `-size`)](#проверки-для-find---проверки-валидируют-подходит-ли-файл-под-условие-поиска--name--type--size)
    - [Операторы для `find` - позволяют объединять проверки (`-and`, `-or`, `-not`)](#операторы-для-find---позволяют-объединять-проверки--and--or--not)
    - [Операции для `find`: `-ok`, `-delete`, `-ls`, `-print`, `-quit`, `-exec`, `xargs`](#операции-для-find--ok--delete--ls--print--quit--exec-xargs)
    - [Параметры `find`: `-depth`, `-maxdepth`, `-mindepth`, `-mount`, `-noleaf`](#параметры-find--depth--maxdepth--mindepth--mount--noleaf)
    - [Создание печочницы из файлов для экспериментов](#создание-печочницы-из-файлов-для-экспериментов)
  - [Глава 18. Архивация и резервное копирование](#глава-18-архивация-и-резервное-копирование)
    - [Сжатие файлов](#сжатие-файлов)
    - [gzip\*\* - \*\*сжатие и распаковка файлов](#gzip---сжатие-и-распаковка-файлов)
    - [bzip2 - сжатие и распаковка файлов с более высоким коэффициентом сжатия](#bzip2---сжатие-и-распаковка-файлов-с-более-высоким-коэффициентом-сжатия)
    - [tar\*\* - утилита для \*\*архивирования файлов (без сжатия)](#tar---утилита-для-архивирования-файлов-без-сжатия)
    - [`zip` - упаковка и сжатие файлов](#zip---упаковка-и-сжатие-файлов)
    - [`rsync` - синхронизация файлов и каталогов (поддеоживает удаленные системы)](#rsync---синхронизация-файлов-и-каталогов-поддеоживает-удаленные-системы)
  - [Глава 19. Регулярные выражения](#глава-19-регулярные-выражения)
    - [Типы регулярных выражений (BRE, ERE)](#типы-регулярных-выражений-bre-ere)
    - [Метасимволы для регулярных выражений](#метасимволы-для-регулярных-выражений)
    - [Классы символов для регулярных выражений](#классы-символов-для-регулярных-выражений)
    - [Поиск в тексте(`grep`) - BRE](#поиск-в-текстеgrep---bre)
    - [`egrep` - расширенный grep с поддержкой ERE](#egrep---расширенный-grep-с-поддержкой-ere)
    - [Примеры использования регулярок для `grep`, `find`, `locate`](#примеры-использования-регулярок-для-grep-find-locate)
  - [Глава 20. Обработка текста](#глава-20-обработка-текста)
    - [`cat` - объединение файлов](#cat---объединение-файлов)
    - [`sort` - сортировка строк](#sort---сортировка-строк)
    - [`uniq` - удаление подряд идущих дубликатов строк](#uniq---удаление-подряд-идущих-дубликатов-строк)
    - [`cut` - вычленение фрагментов из строк](#cut---вычленение-фрагментов-из-строк)
    - [`paste` - объединение строк из нескольких файлов](#paste---объединение-строк-из-нескольких-файлов)
    - [`join` - объединение строк из двух файлов по ключу](#join---объединение-строк-из-двух-файлов-по-ключу)
    - [`comm` - сравнение двух отсортированных файлов](#comm---сравнение-двух-отсортированных-файлов)
    - [`diff` - построчное сравнение файлов](#diff---построчное-сравнение-файлов)
    - [`patch` - применение патчей](#patch---применение-патчей)
    - [`tr` - замена символов одного алфавита символами другого](#tr---замена-символов-одного-алфавита-символами-другого)
    - [`sed` - потоковый текстовый редактор для филтрации и преобразования текста](#sed---потоковый-текстовый-редактор-для-филтрации-и-преобразования-текста)
    - [`aspell` - проверка орфографии](#aspell---проверка-орфографии)
  - [Глава 21. Форматирование вывода](#глава-21-форматирование-вывода)
  - [Глава 22. Печать](#глава-22-печать)
  - [Глава 23. Компиляция программ](#глава-23-компиляция-программ)
    - [Что такое компиляция](#что-такое-компиляция)
    - [Интерпретация](#интерпретация)
    - [Компиляция линуксовых программ из исходников](#компиляция-линуксовых-программ-из-исходников)
- [Часть IV. Сценарии командной оболочки](#часть-iv-сценарии-командной-оболочки)
  - [Глава 24. Создание первого сценария командной оболочки](#глава-24-создание-первого-сценария-командной-оболочки)
    - [Шаги написания сценария](#шаги-написания-сценария)
    - [Формат файла сценария](#формат-файла-сценария)
  - [Глава 25. Начало проекта](#глава-25-начало-проекта)
    - [Создание переменной](#создание-переменной)
    - [Обращение к переменной - `$var`](#обращение-к-переменной---var)
    - [Встроенные документы (here documents) - `<< _EOF_`](#встроенные-документы-here-documents----_eof_)
  - [Глава 26. Проектирование сверху вниз](#глава-26-проектирование-сверху-вниз)
    - [Функции в командной оболочке (`function`)](#функции-в-командной-оболочке-function)
    - [`uptime` - вывод информации о времени работы системы](#uptime---вывод-информации-о-времени-работы-системы)
    - [`.bashrc` - используйте для добавления своих функций, чтобы сделать их доступными в интерактивной оболочке](#bashrc---используйте-для-добавления-своих-функций-чтобы-сделать-их-доступными-в-интерактивной-оболочке)
  - [Глава 27. Управление потоком выполнения: ветвление при помощи if](#глава-27-управление-потоком-выполнения-ветвление-при-помощи-if)
  - [Глава 28. Чтение ввода с клавиатуры](#глава-28-чтение-ввода-с-клавиатуры)
  - [Глава 29. Управление потоком выполнения: циклы while и until](#глава-29-управление-потоком-выполнения-циклы-while-и-until)
  - [Глава 30. Поиск и устранение ошибок](#глава-30-поиск-и-устранение-ошибок)
  - [Глава 31. Управление потоком выполнения: ветвление с помощью case](#глава-31-управление-потоком-выполнения-ветвление-с-помощью-case)
  - [Глава 32. Позиционные параметры](#глава-32-позиционные-параметры)
  - [Глава 33. Управление потоком выполнения: цикл for](#глава-33-управление-потоком-выполнения-цикл-for)
  - [Глава 34. Строки и числа](#глава-34-строки-и-числа)
  - [Глава 35. Массивы](#глава-35-массивы)
  - [Глава 36. Экзотика](#глава-36-экзотика)

## Часть I. Командная оболочка

### Глава 1. Что такое командная оболочка

- Командная оболочка - это программа, которая принимает команды, введенные с клавиатуры, и передает их операционной системе для выполнения.
- Примеры командных оболочек: `bash`, `tcsh`, `zsh`, `ksh`, `sh`.
- Эмулятор терминала - это программа, которая позволяет вводить команды в командную оболочку.
- Примеры эмуляторов терминала: `xterm`, `gnome-terminal`, `konsole`, `rxvt`, `aterm`.
- Приглашение к вводу, пример: `user@hostname:~$`.
- Знак суперпользователя - `#`.

#### Основные клавиши и команды `date`, `cal`, `df`, `free`, `exit`

- KeyUp, KeyDown - перемещение по истории команд.
- `date` - вывод текущей даты и времени.
- `cal` - вывод календаря.
- `df` - вывод информации о дисковом пространстве.
- `free` - вывод информации о памяти.
- `exit` - выход из командной оболочки.

### Глава 2. Навигация

#### Команды `pwd`, `ls`, `cd`

- В Unix-подобных системах всегда имеется только одна файловая система, начинающаяся с корневого каталога `/`.
- Устройсва хранения данных монтируются в каталоги.
- `pwd` - вывод текущего рабочего каталога.
- `ls` - вывод содержимого каталога.
- `cd` - смена рабочего каталога (cd - change directory).
  - `cd ~user` - переход в домашний каталог пользователя.
- `.` - текущий каталог.
- `..` - родительский каталог.

### Глава 3. Исследование системы

#### Команды `ls`, `file`, `less`

- `ls ~ /` - вывод содержимого домашнего каталога и корневого каталога.
- `ls -l` - вывод содержимого каталога в виде списка (l = long).

#### Мнемоника: `command -option argument`.

- `ls -lt` - вывод содержимого каталога в виде списка, отсортированного по времени последнего изменения.
  - `l` - long, `t` - time.
- `ls -r` - вывод содержимого каталога в обратном порядке.
- `ls -d` - вывод информации о каталоге, а не его содержимом.
- `ls -S` - сортировка по размеру.
- Пример длинного формата вывода: `-rw-r--r-- 1 user user 0 Sep 27 15:37 file.txt`.
  - `-rw-r--r--` - права доступа.
    - `pos1` - тип файла: `-` - обычный файл, `d` - каталог, `l` - символическаак ссылка.
    - `pos2-4` - права доступа владельца.
    - `pos5-7` - права доступа группы.
    - `pos8-10` - права доступа остальных пользователей.
  - `1` - количество жестких ссылок.
  - `user user` - владелец и группа.
  - `0` - размер в байтах.
  - `Sep 27 15:37` - дата последнего изменения.
  - `file.txt` - имя файла.
- `file file.txt` - вывод информации о типе файла.
- `less file.txt` - просмотр содержимого файла.
  - `q` - выход.
  - `KeyUp`, `KeyDown` - перемещение по тексту.
  - `1G` - переход в начало файла.
  - `/pattern` - поиск строки.
  - `n` - следующее вхождение.

#### Каталоги в системе linux

- `/` - корневой каталог.
- `/bin` - исполняемые файлы, необходимые для загрузки системы.
- `/boot` - содержит ядро Linux, образ начального RAM-диска и файлы загрузчика.
- `/dev` - файлы устройств.
- `/etc` - конфигурационные файлы.
  - `/etc/passwd` - список всех пользователей.
  - `/etc/crontab` - расписание задач.
  - `/etc/fstab` - таблица монтирования.
- `/home` - домашние каталоги пользователей.
- `/lib` - библиотеки, необходимые для работы программ.
- `/media` - точка монтирования для съемных носителей.
- `/mnt` - точка монтирования для временных файловых систем.
- `/opt` - дополнительное программное обеспечение.
- `/proc` - виртуальная файловая система, содержащая информацию о процессах. Позволяет заглянуть в ядро.
- `/root` - домашний каталог суперпользователя.
- `/sbin` - исполняемые файлы, необходимые для загрузки системы. Запускаются суперпользователем.
- `/tmp` - временные файлы.
- `/usr` - вторичная иерархия каталогов, содержащая исполняемые файлы, библиотеки, заголовочные файлы и документацию обычных пользователей.
  - `/usr/bin` - исполняемые файлы.
  - `/usr/include` - заголовочные файлы.
  - `/usr/lib` - библиотеки.
  - `/usr/local` - дополнительное программное обеспечение. Не входит в состав дистрибутива, но доступно для всех пользователей.
  - `/usr/sbin` - Содержит дополнительные программы для администрирования.
  - `/usr/share` - общие данные. Конфигурационные файлы, документация, иконки.
  - `/usr/share/doc` - документация по установленным пакетам.
  - `/usr/share/man` - справочные страницы.
  - `/var` - содержит изменяемые файлы, такие как журналы, временные файлы, почту и т.д.
    - `/var/log` - журналы.
    - `/var/spool` - почта и принтеры.
    - `/var/tmp` - временные файлы.

### Глава 4. Операции с файлами и каталогами

#### Команды `mkdir`, `cp`, `mv`, `rm`

- Wildcards: `*`, `?`, `[]`, [simbols], [!simbols], [[:class:]].
- `mkdir` - создание каталога.
- `cp source.txt dest.txt` - копирование файла.
  - `cp -a` - копирование со всеми атрибутами.
  - `cp -i` - запрос на подтверждение.
  - `cp -r` - рекурсивное копирование.
  - `cp -u` - копирование только новых файлов.
  - **`cp -v` - подробный вывод.**
- `mv source.txt dest.txt` - перемещение файла. Работает аналогично `cp`.
- `rm file.txt` - удаление файла.
  - `rm -i` - запрос на подтверждение.
  - `rm -r` - рекурсивное удаление.
  - `rm -f` - удаление без запроса на подтверждение.

#### Жесткие ссылки (`ln`)

- По умолчанию каждый файл имеет одну жесткую ссылку.
- Жесткая ссылка не может указывать на файл за пределами собственной файловой системы.
- Влияют на время жизни файла. Когда удаляется последняя жесткая ссылка, файл удаляется.
- Создавая жесткую ссылку, мы фактически создаем дополнительнйы раздел с именем, ссылающийся на тот же раздел с данными.
- `inode` - структура данных, содержащая информацию о файле. Т.е. каждая жесткая ссылка ссылается на определенный индексный узел с содержимым файла.
- `ln file.txt link.txt` - создание жесткой ссылки.

#### Символические ссылки (`ln -s`)

- Были придуманы, чтобы преодолеть ограничения жестких ссылок. Могут ссылаться на файлы вне текущей файловой системы.
- Может провиснуть, если целевой файл удален.
- Символическая ссылка не влияет на время жизни файла.
- Операции над симолической ссылкой применяются к целевому файлу, кроме команд `rm`, которая удаляет саму ссылку.
- `ln -s file.txt link.txt` - создание символической ссылки.

### Глава 5. Работа с командами

#### Чем могут быть команды в Linux (builtins, shell functions, aliases)

- Скомпилированные программы. Например в папке `/usr/bin`. Например `ls`, `cp`, `mv`.
- `shell builtins` - встроенные команды оболочки. Например `cd`, `echo`, `exit`.
- `shell functions` - функции оболочки. Мини сценарии, встроенные в окружение.
- `aliases` - псевдонимы команд. Например `alias ll='ls -l'`.

#### Команды `type`, `which`, `--help`, `man`, `apropos`, `whatis`, `info`

- `type` - вывод типа команды.
- `which` - вывод пути к исполняемому файлу. Ищет только скомпилированные программы.
- `--help` - вывод краткой справки по использованию. Например `ls --help`.
- `man` - вывод справочного руководства со ссылками. Например `man ls`.
  - `man 1 ls` - вывод справки по команде `ls`.
  - `man 5 passwd` - вывод справки по файлу `/etc/passwd`.
  - Т.е. `man section command`. Где `section` - номер раздела справки.
- `apropos` - поиск по ключевым словам в справке. Например `apropos copy`.
  - То же самое что `man -k`.
- `whatis` - вывод краткой информации о команде. Например `whatis ls`.
- `info` - вывод информации о команде в формате `info`. Например `info ls`. Кликабельные ссылки.
  - `info coreutils` - вывод информации о пакете `coreutils`.

#### Разделение команд (`;`)

- Разделение команд `;`, чтобы выполнить несколько команд подряд в одной строке. Например `ls; pwd`.

#### Алиасы (`alias`, `unalias`)

- Создание алиасов `alias ll='ls -l'`.
- Удаление алиасов `unalias ll`.
- Алиасы изчезают после завершения сеанса.

### Глава 6. Перенаправление

#### Потоки (`stdin`, `stdout`, `stderr`)

- `stdin` - стандартный поток ввода.
- `stdout` - стандартный поток вывода. Дескриптор 1.
- `stderr` - стандартный поток ошибок. Дескриптор 2.

#### Перенаправление вывода (`>`, `>>`, `2>`, `2>&1`, `/dev/null`)

- `ls -l /usr/bin > ls-output.txt` - **перенаправление потока вывода** в файл. **Перезапись**. Дескриптор 1 по умолчанию.
- `ls -l /usr/bin >> ls-output.txt` - перенаправление вывода в файл. **Добавление**. Дескриптор 1 по умолчанию.
- `ls -l /usr/bin 2> ls-error.txt` - **перенаправление ошибок** в файл. Перезапись. Дескриптор 2.
- `ls -l /bin/usr > ls-output.txt 2>&1` - **перенаправление всего вывода** в файл (stdout и stderr).
  - Порядок перенаправления важен. Сначала указывается stdout, затем stderr.
  - `ls -l /bin/usr &> ls-output.txt` - **Более короткая запись**.
- `ls -l /bin/usr 2> /dev/null` - удаление нежелательного ввода. Перенаправление в `/dev/null`.
  - `/dev/null` - специальный файл, который игнорирует все, что в него пишется.

#### Конкатенация или вывод содержимого файлов (`cat`)

- `cat file1.txt file2.txt` - вывод содержимого файлов. Выводит по очереди их содержимое и получается конкатенация.
  - `cat` - без аргументов, копирует стандартный ввод в стандартный вывод. Нажать `Ctrl+D`(EOF) для завершения.
  - `cat < file.txt` - перенаправление файла в стандартный ввод. Результат тот же, что и `cat file.txt`.

#### Конвейер (pipes) `cmd1 | cmd2` - стандартный вывод одной команды передается в стандартный ввод другой.

- `ls -l /usr/bin | less` - вывод содержимого каталога постранично.

#### Фильтры (`sort`, `uniq`, `wc`, `grep`, `head`, `tail`, `tee`) - принимают ввод, изменяют его определенным образом и выводят результат.

- `sort` - сортировка строк: `ls -l /usr/bin | sort | less`.
- `uniq` - вывод уникальных строк: `ls -l /usr/bin | sort | uniq | less`.
  - `uniq -d` - вывод дубликатов.
- `wc` - подсчет строк, слов и символов: `ls -l /usr/bin | wc`.
  - `wc -l` - подсчет строк.
  - `wc -w` - подсчет слов.
  - `wc -c` - подсчет символов.
- **`grep` - поиск строк по шаблону(регулярные выражения): `ls -l /usr/bin | grep zip`**.
  - `grep -v` - вывод строк, не содержащих шаблон.
  - `grep -i` - игнорирование регистра.
  - `grep -c` - подсчет строк.
  - `grep -n` - вывод номеров строк.
  - **`grep -r` - рекурсивный поиск**.
- `head` - вывод начала файла: `ls -l /usr/bin | head`.
  - `head -n 10` - вывод первых 10 строк.
- `tail` - вывод конца файла: `ls -l /usr/bin | tail`.
  - `tail -n 10` - вывод последних 10 строк.
  - **`tail -f` - вывод конца файла в реальном времени**.
- `tee` - Т-образное разветвление потока вывода (например в файл и на экран): `ls -l /usr/bin | tee ls-output.txt | less`.
  - Сохраняет вывод команды, передаваемый через конвейер (в данном случае — `ls /usr/bin`), в файл и одновременно передает его в конвейер для дальнейшей обработки.

### Глава 7. Взгляд на мир глазами командной оболочки

#### Подстановка (*)

- После нажатия `Enter` командная оболочка автоматически производит подстановку любых условных символов в командной строке, прежде чем выполнить ее.
- `echo *` - подстановка имен файлов в текущем каталоге. Команда `echo` видит уже результат подстановки.

#### Подстановка путей (Pathname expansion)

- `*` - подстановка любого количества символов.
- `?` - подстановка одного символа.
- `[...]` - подстановка одного символа из набора.
- `[!...]` - подстановка одного символа не из набора.
- `[[:...:]]` - подстановка символов из класса символов.
- `ls -l /usr/bin/[a-c]*` - подстановка файлов, начинающихся с буквы `a`, `b` или `c`.
- **`ls -d .[!.]?*` - шаблон для поиска скрытых файлов**.

#### Подстановка результатов арифметических выражений `$((2 + 2))`

- `echo $((2 + 2))` - подстановка результата арифметического выражения.
- Операторы: `+`, `-`, `*`, `/`, `%`, `**`.

#### Подстановка фигурных скобок `{}`

- Позволяет создавать множество текстовых строк из шаблонов. Начальная часть шаблона называется преамбулой, а конечная — эпилогом.
- Использование пробелов внутри скобок не допускается.
- `echo Front-{A,B,C}-Back` - подстановка всех комбинаций в фигурных скобках.
- `mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12}` - создание каталогов.

#### Подстановка переменных

- `printenv` - вывод переменных окружения.
- `echo $USER` - подстановка значения переменной.
- `echo $((2 * $1))` - подстановка значения аргумента командной строки.
- `echo $((2 * $#))` - подстановка количества аргументов командной строки.
- `echo $((2 * $RANDOM))` - подстановка случайного числа.

#### Подстановка команд

- `echo $(ls)` - подстановка вывода команды.
- `ls -l $(which cp)` - подстановка полного пути к исполняемому файлу.
- `file $(ls /usr/bin/* | grep zip)` - выводит краткую информацию о файлах, содержащих `zip`.
- Старые оболочки вместо `$(...)` использовали обратные кавычки `` `...` ``.

#### Экранирование

- `echo Hello $100.00` - ОШИБКА. Будет попытка подстановки пустой строки вместо $1.
- `echo $(cal)` - удаляет пробелы и табуляции из вывода команды `cal`. Используйте кавычки для сохранения пробелов.
  - Вне кавычек пробелы считаются разделиителями аргументов.

#### Двойные кавычки `"` - экранируют все символы, кроме `$`, `\` и `"`.

- Подстановка параметров, значений переменных, арифметических выражений и команд все еще выполняется: `echo "$USER $((2+2)) $(cal)"`.
- Все специальные символы внутри двойных кавычек теряют свою специальность, кроме `$`, `\` и `"`.
- Благодаря двойным кавычкам вы можете обрабатывать строки, содержащие пробелы.

#### Одинарные кавычки `'` - экранируют все символы.

- `echo '$USER $((2+2)) $(cal)'` - выводит буквально строку внутри кавычек **без подстановок**: `$USER $((2+2)) $(cal)`.

#### Экранирование одного символа

- `echo \$USER` - выводит `$USER` без подстановки переменной.
- Можно использоват чтобы включить специальные символы (`$`, `!`, `&`, ` `) в имена файлов: `ls -l \$file`.

### Глава 8. Продвинутые приемы работы с клавиатурой

#### Цели командной строки

- Выполнить большую часть работы всего несколькими нажатиями клавиш.
- Избежать использования мыши.

#### Полезные для меня сочетания клавиатуры

- `Ctrl+L` - очистка экрана.
- `Alt+T` - обмен местами словами.
- `Alt+L`, `Alt+U` - преобразование слов в нижний и верхний регистр.
- `Ctrl+U` , `Ctrl+K`, `Alt+D` - удаление строки, до курсора, до конца слова.
- `TAB` - автодополнение. Работает с
  - командами (когда дополняемое слово является первым в командной строке),
  - файлами,
  - именами переменных (если слово начинается с `$`),
  - именами копьютеров (если слово начинается с `@`),
  - именами пользователей (если слово начинается с `~`).

#### История команд (`history`, `.bash_history`, `Ctrl+R`)

- `history` - вывод истории команд.
- `.bash_history` - файл истории команд.
- `!<number>` - выполнение команды из истории по номеру.
- `!!` - выполнение последней команды.
- `Ctrl+R` - поступательный поиск по истории команд.
  - Закончив поиск, нажмите `Enter`, чтобы выполнить команду.
  - Нажмите `Ctrl+J`, чтобы скопировать найденную команду в командную строку, не выполняя ее.
  - `Ctrl+R` - чтобы найти следующее вхождение.
  - `Ctrl+С`, `Ctrl+G` - чтобы выйти из режима поиска.
- `!<string>` - выполнение последней команды, начинающейся с `<string>`.
- `!?<string>` - выполнение последней команды, содержащей `<string>`.

### Глава 9. Привилегии

- Unix системы в отличие от MS-DOS являются **многопользовательскими** в дополнение к многозадачности.
  - Несколько пользователей могут одновременно работать на одной системе подключившись к ней через ssh.
  - Пользователи могут получать изображения рабочего стола `ssh -X user@hostname`.

#### Владение файлами и каталогами (`id`, `/etc/passwd`, `/etc/group`, `/etc/shadow`)

- Пользователи могут владеть файлами и каталогами.
- Пользователи могут принадлежать группам, которые могут владеть файлами и каталогами.
- `id` - вывод информации о пользователе и группах.
- `/etc/passwd` - список всех пользователей.
- `/etc/group` - список всех групп.
- `/etc/shadow` - хранит зашифрованные пароли пользователей.

#### Права доступа (`Lrwxrwxrwx`)

- `ls -l` - вывод прав доступа к файлам.
- `-rw-rw-r--`:
  - `pos1` - тип файла:
    - `-` - обычный файл,
    - `d` - каталог,
    - `l` - символическаак ссылка.
  - `pos2-4` - права доступа владельца,
  - `pos5-7` - права доступа группы,
  - `pos8-10` - права доступа остальных пользователей:
    - `w` - запись,
    - `r` - чтение,
    - `x` - выполнение.
- `Lrwxrwxrwx` - символическая ссылка. Все символические ссылки имеют недействительные права доступа. Фактические права доступа определяются файлом, на который ссылается символическая ссылка.

#### `chmod` - изменение прав доступа к файлу (`chmod 777 file.txt`)

- `chmod 777 file.txt` - **восьмеричное представление** прав доступа.
- `chmod ugo+rwx file.txt` - **символьное представление** прав доступа.
  - `u` - владелец,
  - `g` - группа,
  - `o` - остальные пользователи,
  - `a` - все пользователи (синоним `ugo`, для краткости).

- **Символьное представление удобно тем, что позволяет установить единственный атрибут, не затрагивая остальные.**
- `chmod +x file.txt` - добавление права выполнения. Эквивалентно `chmod a+x file.txt`.
- `chmod u+x,go=rx file.txt` - Добавляет право на выполнение для владельца и устанавливает право на чтение и выполнение для группы и всего мира.

#### `umask` - определение разрешений доступа к файлам по умолчанию

- Работают в момент создания файла.
- Маска - это восьмеричное число, которое применяется к правам доступа по умолчанию. Маска вычитается из режима доступа, установленного при создании файла, т.е. `umask 022` означает, что установлены права доступа `rw-r--r--`. Т.е. там где `umask` равен `1` права будут удаляться.
- По дефолту `umask` равен `0002`.

#### Приобретение идентичности другого пользователя (`su`, `sudo`)

- Чаще всего требуется для выполнения команд от имени суперпользователя.
- Но так же можно использовать для выполнения команд от имени другого обычного пользователя.
- **`su` - смена пользователя**.
  - `su -` - смена пользователя на суперпользователя.
  - `su user` - смена пользователя на `user`.
  - `su -l user` - смена пользователя на `user` с загрузкой его окружения.
  - `su -c 'command' user` - выполнение команды от имени `user`.
- **`sudo` - выполнение команды от имени суперпользователя**.
  - Администратор может определить, какие команды и какие пользователи могут использовать `sudo`. Может быть разрешен доступ только к определенным командам.
  - `sudo` продолжает доверять пользователю в течении нескольких минут после первой команды.
  - `sudo` не запускает новую оболочку(и не загружает окружение другого пользователя), а `su` запускает.
  - `sudo -l` - вывод списка команд, которые можно выполнить от имени суперпользователя.

#### Изменение владельца и группы файла (`chown`)

- Для использование этой команда необходимы права суперпользователя.
- `chown user:group file.txt` - изменение владельца и группы файла.
- `chown user file.txt` - изменение владельца файла.
- `chown :group file.txt` - изменение группы файла.

#### `chmod g+s` и `setgid`

- Это полезно для управления доступом к файлам в совместно используемых каталогах, так как все новые файлы и подкаталоги будут принадлежать одной группе, даже если их создают разные пользователи.
- `chmod g+s`: Эта команда устанавливает бит `setgid` (Set Group ID) на указанный каталог.
- `setgid` на каталоге означает, что любые новые файлы или каталоги, созданные в этом каталоге, будут наследовать группу владельца родительского каталога

#### Изменение пароля (`passwd`)

- `passwd` - изменение своего пароля.
- `passwd user` - изменение пароля указанного пользователя.

### Глава 10. Процессы

#### Термины (процесс, PID, UID, daemon)

- В момент **запуска системы** ядро инициирует выполнение нескольких собственных задач в виде процессов и запускает программу с названием `init`.
- `init` запускает сценарии начальной загрузки (**init scripts**), которые запускают все системные службы.
- Службы реализованы в виде демонов (**daemons**) - процессов, которые работают без участия пользователя.
- Принцип по которому программа может запускать другие программы, выражается правилом: **родительский процесс запускает дочерний процесс**.
- Процессы имеют **идентификатор процесса (PID)** и **идентификатор владельца и пользователя (UID)**.

#### `ps` - вывод списка процессов

- `ps` - вывод списка процессов.
- `ps x` - вывод всех процессов, независимо от того, связаны ли они с текущим сеансом. Знак `?` в столбце `TTY` означает, что процесс не связан с терминалом.
- Состояния процессов:
  - `R` - выполняется,
  - `S` - ожидает ввода,
  - `D` - ожидает ввода/вывода,
  - `Z` - зомби,
  - `T` - остановлен,
  - `<` - высокий приоритет,
  - `N` - низкий приоритет.
- `ps aux` - вывод всех процессов в системе.
  - `a` - вывод процессов всех пользователей.
  - `u` - вывод дополнительной информации о процессах.
  - `x` - вывод процессов, не связанных с терминалом.
  - `VSZ` - размер виртуальной памяти процесса.
  - `RSS` - размер физической памяти процесса.

#### `top` - просмотр состояния процессов в динамике

- `top` - вывод списка процессов в динамике.
- `q` - выход.
- `h` - справка.
- `k` - завершение процесса.

#### Управлнеие процессами (`jobs`, `fg`, `bg`, `Ctrl+C`, `Ctrl+Z`)

- `Ctrl+C` - прерывание процесса.
- Фоновые процессы еще называются **заданиями**.
- `process &` - запуск процесса в фоне (задание).
- `jobs` - вывод списка процессов в фоне (заданий).
- `fg %1` - перевод процесса в передний план. `%1` - номер процесса (задания).
- `Ctrl+Z` - приостановка процесса.
  - Процесс переходит в состояние `S` (Stopped).
  - Чтобы возобновить процесс, используйте `fg`.

#### Сигналы (`kill`, `killall`, `kill -l`)

- Это один из способов, которым ОС общается с процессами.
- `kill <PID>` - отправка сигнала процессу.
  - Требуются права суперпользователя, чтобы посылать сигналы процессам, которыми вы не владеете.
  - **`kill -l` - вывод списка сигналов**.
  - `kill -HUP <PID>` - перезапуск процесс (сигнал обрыва связи). Номер сигнала `1`.
  - `kill -INT <PID>` - прерывание процесса. Номер сигнала `2`.
  - `kill -KILL <PID>` - жесткое завершение процесса. Номер сигнала `9`. Ядро немедленно завершает процесс.
  - `kill -TERM <PID>` - завершение процесса. Номер сигнала `15`. Процесс может обработать этот сигнал и завершиться корректно.
  - `kill -CONT <PID>` - возобновление процесса после сигнала `STOP`.
  - `kill -STOP <PID>` - приостановка процесса.
- **`killall <name>` - отправка сигнала всем процессам с указанным именем**.
  - `killall [-u user] [-SIGNAL] processname` - отправка сигнала всем процессам с указанным именем, принадлежащим указанному пользователю.

#### Информация по процессам и аналитика (`pstree`, `vmstat`, `xload`, `tload`)

- `pstree` - вывод дерева процессов.
- `vmstat` - вывод статистики виртуальной памяти.
- `xload` - вывод графика загрузки процессора в X Window.
- `tload` - вывод графика загрузки процессора в текстовом режиме.

## Часть II. Окружение и настройка

Использование окруженния дла настройки некоторых параметров командной оболочки.

### Глава 11. Окружение

#### Что хранит командная оболочка

- Переменные окружения - переменные, которые доступны всем процессам, запущенным в текущем окружении.
- Переменные оболочки - переменные, доступные только оболочке.
  - Программируемые данные
    - Псевдонимы(`alias`) - псевдонимы команд.
    - Функции оболочки(`function`) - мини-сценарии, встроенные в окружение.

#### Вывод переменных окружения и оболочки (`set`, `printenv`, `alias`)

- `set` - вывод всех переменных окружения и оболочки.
- `printenv` - вывод переменных окружения.
- `printenv USER` - вывод значения переменной окружения.
- `echo $USER` - вывод значения переменной оболочки.
- `alias` - вывод всех псевдонимов.

#### Как загружается командная оболочка

- Читает файлы настроек при запуске.
- Наследует переменные окружения от родительского процесса.
- `export PATH` - экспорт переменной окружения. Делает содержимое переменной доступным для дочерних процессов.
- `source ~/.bashrc` - заставляет оболочку перечитать файл настроек.
- Если вы не системный администратор, то вам доступны изменения только в файлах домашнего каталога.
- **Login** shell session - оболочка, которая запускается при входе в систему.
  - `/etc/profile` - общие настройки для всех пользователей.
  - `~/.bash_profile` - настройки для конкретного пользователя. Для расширения и/или переопределения общих настроек.
  - `~/.bash_login` - настройки для конкретного пользователя.
  - `~/.profile` - если нет `~/.bash_profile` и `~/.bash_login`.
- **Non-login** shell session - оболочка, которая запускается внутри графической среды.
  - `/etc/bash.bashrc` - общие настройки для всех пользователей.
  - `~/.bashrc` - настройки для конкретного пользователя. Для расширения и/или переопределения общих настроек.
    - `export HISTCONTROL=ignoredups` - игнорирование дубликатов в истории команд.

#### Редакторы текстовых файлов

- С графическим интерфейсом: `gedit`, `kate`, `kwrite`.
- Без графического интерфейса: `nano`, `vim`, `emacs`.

### Глава 12. Плавное введение в vi

- `vi filename` - запуск редактора vi. Если файл не существует, он будет создан.
- `vim filename` - запуск улучшенной версии vi.
- `vim file1 file2` - открытие нескольких файлов.

#### Режимы работы vi (командный, вставки)

- **Командный режим** - режим, в котором вы можете перемещаться по файлу и выполнять команды. Запускается при запуске vi.
  - `:...` - ex-команды (символ `:` начинает ex-команду).
  - `<key press>` - выполнение команды.
  - `i` - переход в режим вставки.
  - `a` - переход в режим вставки после курсора.
- **Режим вставки** - режим, в котором вы можете вводить текст.
  - `ESC ESC` - переход в режим команд.

#### Undo/Redo

- `u` - отмена последнего действия.

#### Перемещение

- `Стрелки` - перемещение курсора.
- `0` - перемещение к началу строки.
- `$` - перемещение к концу строки.
- `w` - перемещение к следующему слову.
- `b` - перемещение к предыдущему слову.
- `12G` - перемещение к 12 строке.

#### Добавление

- `o` - добавление новой строки ниже и переход в режим вставки.
- `O` - добавление новой строки выше и переход в режим вставки.

#### Удаление

- `x` - удаление символа под курсором.
- `dd`, `5dd` - удаление строки, удаление 5 строк.
- `dw`, `5dw` - удаление слова, удаление 5 слов.
- `d$` - удаление до конца строки.
- `d^` - удаление от текущей позиции до начала строки.
- `J` - объединение текущей строки со следующей (удаление конца строки).

#### Поиск

- `f<char>` - поиск символа в строке.
- `/pattern` - поиск шаблона в файле.
- `:%s/pattern/replacement/g` - замена шаблона во всем файле.
- `:1,5s/pattern/replacement/g` - замена шаблона в диапазоне строк c 1 по 5.
- `:1,5s/pattern/replacement` - поиск и замена только первого вхождения в каждой с 1 по 5 строке.
- `:1,5s/pattern/replacement/c` - ... еще запрашивать подтверждение.

#### Копирование

- `yy`, `5yy` - копирование строки, копирование 5 строк.
- `p` - вставка скопированного текста.
- `:r filename` - вставка содержимого файла в текущую позицию (по сути копирование).
- `Yp` - дублирование строки.

#### Работа с файлами

- `:q` - выход.
- `:q!` - выход без сохранения.
- `:w` - сохранение.
- `ZZ` - сохранение всех файлов и выход.
- `:e filename` - открытие файла.
- `:buffers`, `:ls` - вывод списка редактируемых файлов.
- `:bn`, `:bp`, `:b<number>` - переключение между файлами.

### Глава 13. Настройка приглашения к вводу

- `echo $PS1` - переменная, содержащая строку приглашения к вводу.
- `ps1_old=$PS1` - сохранение текущего значения переменной.
- `$PS1="new prompt"` - изменение значения переменной.
- `vi ~/.bashrc` - настройка находится тут. У меня получилось изменить цвет приглашения к вводу через редактирование файла. Потом надо сделать `source ~/.bashrc`.

## Часть III. Типичные задачи и основные инструменты

### Глава 14. Управление пакетами

#### Package management - это методика установки и управления программным обеспечением в системе.

- В первые года развития Linux для установки программ требовалось скачивать и **компилировать исходный код**.
- Пакеты между различными дистрибутивами несовместимы.
- **Файл пакета** - это архив, содержащий программу и метаданные о ней.
- Готовые пакеты помещаются в ценральный **репозиторий** дистрибутива.
- Дистрибутивы обычно имеют тестовые и стабильные репозитории.
- Драйверы устройств распространяются почти также как и программы, только они не выделяются в репозитории дистрибутива, а включаются в ядро.

#### Инструменты управления пакетами (`dpkg`, `rpm`, `apt`, `yum`, `zypper`)

- **Низкоуровневые** - устанавливают пакеты напрямую.
  - **`dpkg`** - Debian, Ubuntu.
  - **`rpm`** - Red Hat, Fedora.
  - **`rpm2cpio`** - конвертация rpm в cpio.
  - **`cpio`** - утилита для работы с архивами.
- **Высокоуровневые** - устанавливают пакеты и их **зависимости**.
  - **`apt`** - Debian, Ubuntu.
  - **`yum`** - Red Hat, Fedora.
  - **`zypper`** - OpenSUSE.

#### Низкоуровневые команды (`dpkg -i`)

- `dpkg -i package.deb` - установка/обновление пакета.
- `dpkg --list` - вывод списка установленных пакетов.
- `dpkg --status package` - вывод информации о пакете.
- `dpkg --search file` - поиск пакета по установленному файлу.

#### Команды для работы с репозиторием (`apt-get ...`)

- `apt-get update` - обновление списка пакетов.
- `apt-get upgrade` - обновление всех пакетов.
- `apt-cache search pattern` - поиск пакета.
- `apt-cache show package` - вывод информации о пакете.
- `apt-get install package` - установка пакета.
- `apt-get remove package` - удаление пакета.

### Глава 15. Устройства хранения

#### Монтирование (`mount`, `umount`)

- Монтирование - подключение самого устройства к дереву файловой системы.
- Unix-подобные операционные системы поддериживают единое дерево файловой системы, к разным точкам которого подключаются дополнительные устройства. Этот подход отличается от Windows, где каждое устройство имеет свое собственное дерево файлов.
- Файл `/etc/fstab` содержит информацию о том, какие устройства монтируются при загрузке системы.
- `mount` - вывод списка подключенных устройств. Там не только устройства хранения, но и многое другое.
- `umount` - отключение устройства. Размонтирование устройства влечет за собой запись всех оставшихся данных в это устройство, чтобы его можно было безопасно извлеч.
- Процесс размонтирования и повторного монтирования.
  - `umount /dev/sdb1` - размонтирование устройства.
  - `mount /dev/sdb1 /mnt` - монтирование устройства.

#### Определение названий устройств (`ls /dev`, `/var/log/syslog`)

- `ls /dev` - вывод списка устройств.
  - `/dev/fd*` - дискеты.
  - `/dev/hd*` - IDE-устройства.
  - `/dev/sd*` - SCSI-устройства (включая USB-устройства).
  - `/dev/sr*` - CD/DVD-устройства.
- `sudo tail -f /var/log/syslog` - вывод логов ядра. **Можно увидеть какие устройства подключаются и какие имена им присваиваются**.
  - `kubuntu kernel:  sda: sda1`
    - `sda` - физическое устройство.
    - `sda1` - раздел на устройстве.
  - Затем можно сделать монтирование: `mount /dev/sda1 /mnt`.

#### Управление разделами диска (`fdisk`)

- `sudo fdisk /dev/sda` - запуск утилиты для управления разделами диска.
  - `p` - вывод таблицы разделов.
  - `n` - создание нового раздела.
  - `d` - удаление раздела.
  - `w` - запись изменений.
  - `q` - выход без сохранения.
  - `t` - изменение типа раздела: `83` - Linux, `82` - Linux swap.

#### Управление файловыми системами (`mkfs`, `fsck`)

- `sudo mkfs -t ext4 /dev/sda1` - создание файловой системы.
- `sudo fsck /dev/sda1` - проверка файловой системы.
  - Перед запуском `fsck` необходимо размонтировать файловую систему.
  - Может восстановить поврежденные фрагменты файлов. Они будут помещены в каталог `lost+found`.

#### Создание копии диска (`dd`, `md5sum`)

- `dd` - утилита, которая делает низкоуровневую копию данных, т.к. копирует блоки данных, а не файлы.
- `sudo dd if=/dev/sda of=/dev/sdb` - копирование всего диска между устройствами.
- `sudo dd if=/dev/sda of=~/disk.img` - копирование всего диска в файл.
- `md5sum /dev/sda` - вычисление контрольной суммы диска.

### Глава 16. Сети

#### Исследование и мониторинг сети (`ping`, `traceroute`, `netstat`)

- `ping google.com` - **проверка доступности хоста**.
  - Большинство сетевых устройств принимает эти пакеты(пакеты ICMP Echo Request) и отправляет обратно пакеты с ответом(пакеты ICMP Echo Reply).
  - Для повышения безопасности сетевые устройства могут блокировать ICMP-пакеты.

- `traceroute google.com` - **определение маршрута пакетов**.
  - Показывает все узлы, через которые проходят пакеты.
  - Для маршрутизаторов, которые блокируют ICMP-пакеты выводится `* * *`.

- **Вывод параметров настройки сети**
  - `netstat -ie` - вывод информации о сетевых интерфейсах.
  - `netstat -r` - вывод таблицы маршрутизации.

#### Передача файлов по сети (`ftp`, `lftp`, `wget`, `ssh`, `scp`, `sftp`)

- **Небезопасные(нешифрованные) взаимодействия**
  - `ftp ftp.gnu.org` - подключение к FTP-серверу.
    - `Name (ftp.gnu.org:sergey): anonymous` - ввод логина. Анонимный доступ позволяет войти без пароля.
    - `cd /pub/gnu` - переход в каталог.
    - `ls` - вывод списка файлов.
    - `get file` - скачивание файла.
    - `put file` - загрузка файла.
    - `bye` - выход.
  - `lftp ftp.gnu.org` - улучшенный FTP-клиент.
    - Поддерживает восстановление загрузки файлов.
    - Поддерживает фоновую загрузку файлов.
  - `wget http://www.gnu.org/software/bash/manual/bash.pdf` - загрузка файла по HTTP.
- **Безопасные взаимодейтвия**
  - `OpenSSH-server` - устанавливается на сервере, чтобы позволить клиентам подключаться к нему.
  - `OpenSSH-client` - устанавливается на клиенте, чтобы позволить подключаться к серверу.
  - **ssh**
    - `ssh user@hostname` - подключение к удаленному хосту под пользователем `user`.
    - `ssh hostname` - подключение к удаленному хосту под текущим пользователем.
    - При установлении подключения будет выведена строка про finferprint ключа.
      - Это значит, что ключ сервера неизвестен. Либо это вы впервые подключаетесь к серверу, либо атака Man-in-the-middle.
      - Важная строка в вываде: `Offending key in /home/sergey/.ssh/known_hosts:1` - указывает на конкртный ключ в файле, который вызвал ошибку.
    - `ssh remotehost command` - выполнение одиночной команды на удаленном хосте:
      - `ssh remotehost 'ls *'` - кавычки показывают границы команды.
    - `ssh -X user@hostname` - подключение с возможностью получения изображений рабочего стола.
  - **scp и sftp**
    - `scp file user@hostname:/path` - копирование файла на удаленный хост.
    - `scp user@hostname:/path/file .` - копирование файла с удаленного хоста.
    - `sfpt user@hostname` - подключение к удаленному хосту по SFTP.

### Глава 17. Поиск файлов

#### `locate file` - поиск файла в базе данных имен файлов

- `updatedb` - обновление базы данных. Это обновление происходит автоматически раз в день (cron).
- `locate file | grep pattern` - поиск файла по шаблону.

#### `find` - сложный поиск файлов

- `find / -name file` - поиск файла по имени.
- `find / | wc -l` - подсчет количества файлов.
- `find / -type f -size +100M` - поиск файлов размером более 100Мб.
- Важно не забывать кавычки, чтобы не дать оболочке интерпретировать шаблоны: `find / -name '*.txt'`.

#### Проверки для `find` - проверки валидируют подходит ли файл под условие поиска (`-name`, `-type`, `-size`)

- `-name` - поддеоживает шаблоны: `*` - любое количество символов, `?` - один символ.
- `-type`: `b` - блочный файл, `c` - символьный файл, `d` - каталог, `l` - символьная ссылка, `p` - именованный канал, `s` - сокет.
- `-size`: `+` - больше, `-` - меньше, `=` - равно.
  - units: `c` - байты, `k` - килобайты, `M` - мегабайты, `G` - гигабайты.
- `-nouser`, `-nogroup` - поиск файлов без владельца. Подходит для обнаружения следов злоумышленников.
- `-mtime`, `-atime`, `-ctime` - поиск файлов по времени модификации, доступа, изменения.
- `-newer file` - поиск файлов, измененных после указанного файла.
- `-perm` - поиск файлов по правам доступа.
- `-samefile file` - поиск файлов, которые являются символьными ссылками на указанный файл.

#### Операторы для `find` - позволяют объединять проверки (`-and`, `-or`, `-not`)

- `-and` - логическое И. По умолчанию все проверки объединяются логическим И.
  - Если первая проверка возвращает `false`, то вторая проверка не выполняется.
- `-or` - логическое ИЛИ.
  - Если первая проверка возвращает `true`, то вторая проверка не выполняется.
- `-not` - логическое НЕ. Пример: `find / -not -name '*.txt'`.
- `( ... )` - группировка проверок.
- `find ~ -name '*.txt' -or -name '*.md'`.

#### Операции для `find`: `-ok`, `-delete`, `-ls`, `-print`, `-quit`, `-exec`, `xargs`

- `find ~ -name '*.pdf' -or -name '*.md' -and -size +200k -ok head {} \;`
- `find ~ -name '*.pdf' -or -name '*.md' -and -size +200k -ok ls -l {} \;`
- `-ok` - запрос на подтверждение перед выполнением команды.
- `-delete` - удаление найденных файлов.
- `-ls` - вывод информации о найденных файлах.
- `-print` - вывод пути к найденным файлам. Выполняется по умолчанию.
- `-quit` - завершение поиска после первого найденного файла.
- **`-exec command {} \;`** - выполнение команды над найденным файлом.
  - `find ~ -name '*.pdf' -or -name '*.md' -and -size +200k -exec ls -l {} +`   - выполнение команды над всеми найденными файлами.
  - `find ~ -name '*.pdf' -or -name '*.md' -and -size +200k -exec ls -l {} \;`  - выполнение команды над каждым найденным файлом.
  - `{}` - это плейсхолдер, который заменяется на имя файла.
  - `find / -name '*.txt' -exec cp {} /tmp \;` - копирование всех файлов с расширением `.txt` в `/tmp`.
  - `-ok command {} \;` - запрос на подтверждение перед выполнением команды.
- **`xargs`** - принимает входные данные со стандартного ввода и преобразует из в список аргументов для указанной команды
  - По сути это альтернатива `-exec command {} +`, которая так же позволяет обрабатывать большое количество файлов за один раз.
  - Но я так понял, что `xargs` может принимать не долько файлы, но и другие данные.
  - Когда длина командной строки превышает максимальное значение, `xargs` разбивает список на несколько частей и вызывает команду несколько раз.
  - `find ~ -name '*.txt' | xargs ls -l` - вывод информации о найденных файлах.

#### Параметры `find`: `-depth`, `-maxdepth`, `-mindepth`, `-mount`, `-noleaf`

- `-depth` - сначала обрабатываются дочерние элементы, затем родительские.
  - Этот параметр по дефолту применяется с командой `-delete`.
  - `find / -depth -name '*.txt'`.
- `-maxdepth` - ограничение глубины поиска.
  - `find / -maxdepth 2 -name '*.txt'`.
- `-mindepth` - минимальная глубина поиска.
  - `find / -mindepth 2 -name '*.txt'`.
- `-mount` - не выполнять поиск в других файловых системах.
  - `find / -mount -name '*.txt'`.
- `-noleaf` - не использовать оптимизацию поиска, опираясь на предположение, что ведется поиск в Unix-подобной файловой системе.
  - `find / -noleaf -name '*.txt'`.

#### Создание печочницы из файлов для экспериментов

- `mkdir -p playground/dir-{00{1..9},0{10..99},100}` - создание директорий.
- `touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}` - создание файлов.
- `touch` - создание пустого файла, либо обновление времени последнего доступа существующего файла.
- `stat file` - вывод информации о файле.
- `find -name "file-O" | grep *005 | xargs stat` - поиск файла по имени, затем фильтр по пути, затем вывод информации о файле.

### Глава 18. Архивация и резервное копирование

#### Сжатие файлов

- **C потерями (lossy)**
  - JPEG - сжатие изображений.
  - MP3 - сжатие аудио.
- **Без потерь (lossless)**
  - Кодирование длин серий (RLE) - кодирование последовательностей одинаковых символов.

#### gzip** - **сжатие и распаковка файлов

- `gzip file` - сжатие файла. Старый файл удаляется.
- `gzip -k file` - сжатие файла. Старый файл остается.
- `gzip -r dir` - сжатие директории, причем сжимаются все файлы внутри, но не сама директория.
  - `find . -name '*.gz' -exec gzip -d {} \;` - распаковка всех файлов в директории рекурсивно.
- `gzip -d file.gz` или `gunzip file.gz` - распаковка файла.
- `gzip -f file` - сжатие файла с заменой существующего архива.
- `gzip -c file` - вывод сжатого файла в стандартный вывод.
- `gzip -v file` - вывод информации о сжатии.

#### bzip2 - сжатие и распаковка файлов с более высоким коэффициентом сжатия

#### tar** - утилита для **архивирования файлов (без сжатия)

- `tar -cvf archive.tar file1 file2` - создание архива.
  - `c` - создание архива.
  - `v` - вывод списка файлов.
  - `f` - указание имени архива.
- `tar -xvf archive.tar` - распаковка архива.
  - `x` - распаковка архива.
  - По умолчанию внутри используются относительные пути. Поэтому вы можете распаковать архив в любую директорию с сохранением структуры.
  - Вам нужно быть суперпользователем, для того чтобы сохранить владельца и группу.
- `tar --wildcards -xvf archive.tar '*.txt'` - распаковка файлов по шаблону.
- `find playground -name 'file-A' -exec tar -rvf archive.tar {} +` - добавление файлов в архив по шаблону.
  - Можно использовать find для поиска файлов изменных за последние 7 дней и добавить их в архив. Таким образом можно получить инкрементальное резервное копирование.
- **`find playground -name 'file-A' | tar cf - --files-from=- | gzip > playground.tgz` - работа через пайпы**
  - `cf -` - вывод архива в стандартный вывод, этот ввод передается в gzip.
  - `--files-from=-` - чтение списка файлов из стандартного ввода.
- `ssh user@host 'tar cf - Documents' | tar xf -` - передача сжатых файлов по ssh и их распаковка.
  - `xf -` - чтение архива из стандартного ввода и распаковка.

#### `zip` - упаковка и сжатие файлов

- `zip -r archive.zip dir` - создание архива.
- `unzip -l archive.zip` - вывод списка файлов в архиве без распаковки.
  - `-l` - вывод списка файлов.
  - `-v` - вывод подробной информации о каждом файле.
- `unzip archive.zip` - распаковка архива.
- `find playground -name "file-A" | zip -@ file-A.zip` - создание архива из файлов по шаблону через пайпы.
  - `-@` - чтение списка файлов из стандартного ввода.
- `ls -l playground | zip playground2.zip -` - создание архива из файлов в директории.
- `-` - чтение списка файлов из стандартного ввода.
- `upzip -p archive.zip` - вывод содержимого архива в стандартный вывод.

#### `rsync` - синхронизация файлов и каталогов (поддеоживает удаленные системы)

- Позволяет быстро обнаруживать различия между двумя каталогами и копировать только измененные данные (миниальный объем информации).
- Копирование из удаленной системы в удаленную систему не поддерживается.
- `rsync -av playground playground2` - синхронизация двух директорий.
- `sudo rsync -avz --delete --rsh=ssh /etc /home /usr/local user@host:/backup` - резервное копирование системных файлов на удаленный хост.
  - `a` - архивный режим. Копирование файлов рекурсивно, сохранение прав доступа, времени модификации и других атрибутов.
  - `v` - вывод информации о процессе.
  - `z` - сжатие данных.
  - `--rsh=ssh` - использование ssh для передачи данных.
  - `--delete` - удаление файлов на удаленном хосте, которых нет на локальном.
- `rsync -av -delete rsync://rsync.gtlib.gatech.edu/dir1/dir2/file` - синхронизация с удаленным репозиторием.
  - `rsync://rsync.gtlib.gatech.edu/dir1/dir2/file` - адрес удаленного репозитория.
  - `fedora-devel` - локальная директория.

### Глава 19. Регулярные выражения

- Регулярные выражения - это всего лишь символическая форма записи, используемая для идентификации шаблонов в тексте.
- `grep` = Global Regular Expression Print

#### Типы регулярных выражений (BRE, ERE)

- BRE - **Basic Regular Expressions**.
  - Поддерживаются стандартом POSIX.
- ERE - **Extended Regular Expressions**.
  - Поддерживаются в `grep -E`.
  - Включают в себя дополнительные метасимволы: `+`, `?`, `|`, `()`, `{}`.

#### Метасимволы для регулярных выражений

- `.` - один любой символ.
- `^` - начало строки.
- `$` - конец строки.
- `*` - ноль или более вхождений предыдущего символа.
- `+` - одно или более вхождений предыдущего символа.
- `[]` - один из символов в скобках.
- `[^]` - один из символов не в скобках.
- `()` - группировка символов.
- `\` - экранирование метасимволов.
- `|` - логическое ИЛИ.
- `{n}` - n вхождений предыдущего символа.
- `{n,}` - n или более вхождений предыдущего символа.
- `{n,m}` - от n до m вхождений предыдущего символа.
- `[a-z]` - один символ из диапазона.

#### Классы символов для регулярных выражений

- `[[:word:]]` - буквы, цифры и знак подчеркивания.
- `[[:alnum:]]` - буквы и цифры.
- `[[:alpha:]]` - буквы.
- `[[:digit:]]` - цифры.
- `[[:lower:]]` - строчные буквы.
- `[[:upper:]]` - заглавные буквы.
- `[[:space:]]` - пробельные символы.
- `[[:punct:]]` - знаки пунктуации.
- `[[:print:]]` - печатаемые символы.
- `[[:graph:]]` - печатаемые символы без пробелов.

#### Поиск в тексте(`grep`) - BRE

- `grep params pattern file` - поиск шаблона в файле.
- `grep bzip dirlist*.txt` - поиск слова `bzip` в файлах.
- `grep -l bzip dirlist*.txt` - вывод имен файлов, где найдено слово `bzip`.
  - `-i` - игнорирование регистра.
  - `-v` - вывод строк, не содержащих шаблон.
  - `-n` - вывод номера строки.
  - `-c` - вывод числа совпавших строк.
  - `-l` - вывод только имен файлов, где найден шаблон.
  - `-L` - вывод только имен файлов, где не найден шаблон.
  - `-h` - подавление вывода имен файлов при поиске в нескольких файлах.

- **Использование регулярных выражений с grep**
  - `grep -h ^zip dirlist*` - вывод строк, начинающихся с `zip`.
  - `grep -h zip$ dirlist*` - вывод строк, заканчивающихся на `zip`.
  - `grep -h ^[0-9] dirlist*` - вывод строк, начинающихся с цифры.
  - `grep -h ^[^0-9] dirlist*` - вывод строк, начинающихся не с цифры.
  - `grep -h ^[abc] dirlist*` - вывод строк, начинающихся с `a`, `b`, `c`.
  - `grep -h 'a\{2\}' dirlist*` - вывод строк, содержащих два символа `a` подряд. **Обратите внимание на экранирование фигурных скобок. Оно необходимо, чтобы оболочка не интерпретировала их как часть синтаксиса оболочки.**

- **Использование классов символов в регулярных выражениях**
  - `grep -h '[[:digit:]]' dirlist*` - вывод строк, содержащих цифры.

#### `egrep` - расширенный grep с поддержкой ERE

- `grep -E` - аналог `egrep`.
- `grep -Eh '^(bz|gz|zip)' dirlist*.txt` - вывод строк, начинающихся с `bz`, `gz`, `zip`.
- `echo "(555) 123-4567" | grep -E '^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$'` - поиск телефонного номера.
  - `?` - ноль или одно вхождение предыдущего символа.
  - `\(` - экранирование скобки.

#### Примеры использования регулярок для `grep`, `find`, `locate`

- `for i in {1..10}; do echo "(${RANDOM:0:3}) ${RANDOM:0:3}-${RANDOM:0:4}" >> phonelist.txt; done` - генерация телефонных номеров.
  - `grep -Evn '\([0-9]{3}\) [0-9]{3}-[0-9]{4}' phonelist.txt` - поиск плохих номеров и вывод их номеров строк.
- `find . -regex '.*\(\.txt\|\.md\)$'` - поиск файлов с расширениями `.txt` и `.md`.
- `locate --regex 'bin/(bz|gz|zip)'` - поиск файлов в директории `bin` с расширениями `bz`, `gz`, `zip`.
- `zgrep -El 'regex|regular expression' *.gz` - поиск в архивированных файлах. Запустите поиск в папке `cd /usr/share/man/man1`.
- `less` и
- `vim` - имеют встроенную поддержку регулярных выражений (vim поддерживает только BRE).
  - `/pattern` - поиск шаблона в тексте.
  - `n` - следующее вхождение.
  - `N` - предыдущее вхождение.
  - `?pattern` - поиск назад.
  - `q` - выход.

### Глава 20. Обработка текста

#### `cat` - объединение файлов

- `cat > foo.txt` - запись в файл в интерактивном режиме. `Ctrl+D` - завершение записи.
- `cat -A foo.txt` - вывод невидимых символов.
- `cat -n foo.txt` - вывод номеров строк.
- `cat -s foo.txt` - подавить вывод множества пустых строк.

#### `sort` - сортировка строк

- `sort > sorted.txt` - сортировка строк в файл в интерактивном режиме. `Ctrl+D` - завершение записи.
- `sort file1 file2 file3 > sorted.txt` - сортировка строк из нескольких файлов в один файл.
  - `-b` - игнорирование начальных пробелов при сортировке.
  - `-f` - игнорирование регистра при сортировке.
  - `-n` - сортировка чисел. Наприер, `10` будет идти после `9`.
  - `-r` - сортировка в обратном порядке.
  - `-k` - сортировка по ключу. Например, `-k 2` - сортировка по второму столбцу.
  - `-t` - указание разделителя полей. По умолчанию это пробел.
  - `-m` - слияние отсортированных файлов. Позволяет объединить несколько файлов в общий результат без выполнения дополнительной сортировки.
  - `-o` - вывод результата в файл вместо стандартного вывода.
- `du -s /usr/share/* | sort -nr | head` - вывод 10 самых больших директорий в `/usr/share`.
  - `du` - вывод информации о дисковом пространстве.
- `ls -l /usr/bin | sort -nr -k 5 | head` - вывод 10 самых больших файлов в `/usr/bin`.
  - `ls -l` - вывод информации о файлах.
  - `-k 5` - сортировка по пятому столбцу.
    - Программа sort способна обрабатывать поля по отдельности
    - Пробельные символы интерпретируются как разделители полей.
- `sort --key=1,1 --key=2n distros.txt` - сортировка по первому столбцу, затем по второму столбцу.
  - `--key=1,1` - сортировка по первому столбцу.
  - `--key=2n` - сортировка по второму столбцу как чисел.
- `sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt` - сортировка по третьему столбцу, начиная с седьмого символа, затем по первому символу, затем по четвертому символу.
  - `3.7nbr` - седьмой символ третьего столбца.
  - `3.1nbr` - первый символ третьего столбца.
  - `3.4nbr` - четвертый символ третьего столбца.
- `sort -t ':' -k 7 /etc/passwd | head` - сортировка по седьмому полю в файле `/etc/passwd`.
  - `-t ':'` - указание разделителя полей.

#### `uniq` - удаление подряд идущих дубликатов строк

- `sort foo.txt | uniq` - удаление дубликатов строк.
  - `-c` - вывод числа повторений строки.
  - `-d` - вывод только дубликатов строк.
  - `-u` - вывод только уникальных строк.
  - `-i` - игнорирование регистра.
  - `-f n` - игнорирование первых n символов в каждой строке.

#### `cut` - вычленение фрагментов из строк

- `cut -d ':' -f 1,7 /etc/passwd` - вывод первого и седьмого поля в файле `/etc/passwd`.
  - `-d ':'` - указание разделителя полей.
  - `-f 1,7` - вывод первого и седьмого поля.
  - `--complement` - вывод всех полей, кроме указанных.

#### `paste` - объединение строк из нескольких файлов

- paste выполняет операцию, обратную команде cut. Вместо извлечения колонок текста из файла она добавляет одну или несколько колонок текста в файл.
- `paste file1 file2` - объединение строк из двух файлов.
  - `-d ':'` - указание разделителя строк.

#### `join` - объединение строк из двух файлов по ключу

- Похожа на paste, но объединяет строки по ключу. Ассоциируется у многих с реляционными базами данных.
- Важно, чтобы файлы были отсортированы по ключевому полю.
- `join file1 file2` - объединение строк из двух файлов по ключу.
  - `-t ':'` - указание разделителя полей.
  - `-1 2` - указание ключа для первого файла.
  - `-2 1` - указание ключа для второго файла.

#### `comm` - сравнение двух отсортированных файлов

- `comm file1 file2` - сравнение двух файлов.
  - `-1` - вывод строк, присутствующих только в первом файле.
  - `-2` - вывод строк, присутствующих только во втором файле.
  - `-3` - вывод строк, присутствующих в обоих файлах.

#### `diff` - построчное сравнение файлов

- `diff file1 file2` - сравнение двух файлов.
  - `-c` - контекстный вывод.
  - `-u` - унифицированный вывод. Похож на вывод git diff.

#### `patch` - применение патчей

- `diff -u file1 file2 > patch` - создание патча.
- `patch file1 < patch` - применение патча.
- `diff -Naur file1.txt file2.txt > patchfile.txt` - создание патча с учетом новых файлов.
  - `-N` - включение новых файлов в патч.
  - `-u` - унифицированный вывод.
  - `-a` - обработка текстовых файлов.
- `patch < patchfile.txt` - применение патча.
  - не пришлось указывать целевой файл, потому что diff-файл уже содержит имена файлов в заголовке.

#### `tr` - замена символов одного алфавита символами другого

- Принимает данные из стандартного ввода и выводит результат в стандартный вывод.
- Принимает два набора символов и заменяет символы из первого набора символами из второго набора.
- Поддерживает списки перечисления, диапазоны и классы символов.
- Позволяет удалять символы, если второй набор пуст.
- `echo "lowercase letters" | tr a-z A-Z` - замена строчных букв на заглавные.
- `echo "secret text" | tr a-zA-Z n-za-mN-ZA-M` - шифрование текста с помощью шифра Цезаря. Cдвиг на 13 позиций (половину алфавита), который при повторении расшифровывает текст.
- `echo "aaabbbccc" | tr -s ab` - удаление дубликатов символов.
  - `-s` - сжатие пробелов.

#### `sed` - потоковый текстовый редактор для филтрации и преобразования текста

- `sed` означает **Stream EDitor**.
- Поддерживает регулярные выражение, в том числе работу с группами: `\1`, `\2`.
  - `sed 's/([0-9]{2})/([0-9]{2})/([0-9]{4})$/\3-\1-\2/' distros.txt` - преобразование даты из формата `MM/DD/YYYY` в формат `YYYY-MM-DD`.
- `echo "front" | sed 's/front/back/'` - замена слова `front` на `back`.
  - `s` - замена.
- `echo "front" | sed '1s/front/back/'` - замена слова `front` на `back` в первой строке.
  - `1` - номер строки.
  - `$` - последняя строка.
  - `-n` - подавление вывода.
  - `p` - вывод строки.
  - `d` - удаление строки.
  - `i` - вставка текста в начало текущей строки.
  - `a` - вставка текста в конец текущей строки.
  - `=` - вывод номера строки.
  - `y` - перекодирование символов, в отличие от `tr`, требует чтобы количество символов в обоих наборах было одинаковым.
- `echo "aaabbbccc" | sed 's/b/B/g'` - замена всех символов `b` на `B`.
  - `g` - замена всех вхождений в строке, а не только первого.

#### `aspell` - проверка орфографии

- `aspell check file` - проверка орфографии файла.
- `aspell list < file` - вывод списка слов, которые не прошли проверку.
- `spell -H check foo.txt` - проверка орфографии файла с игнорированием HTML-тегов.

### Глава 21. Форматирование вывода

### Глава 22. Печать

### Глава 23. Компиляция программ

- Доступность исходного кода - это одно из ключевых преимуществ Linux.
- Для получения самой последней версии программы придется ее скомпилировать.

#### Что такое компиляция

- Процессор работает на **машинном языке** - наборе инструкций, понятных процессору.
- Язык **ассемблера** - низкоуровневый язык программирования в виде мнемонических команд, которые преобразуются в машинный код.
- **Высокоуровневые языки** программирования - языки, близкие к человеческому языку. Fortran, C, C++, Java, Python.
- **Компилятор** - программа, которая преобразует исходный код на высокоуровневом языке в машинный код (объектный файл).
- **Компоновка** - процесс объединения нескольких объектных файлов в один исполняемый файл.
- **Библиотеки** - наборы функций, которые могут быть использованы в программе.
- **Linker** - программа, которая объединяет объектные файлы и библиотеки в исполняемый файл.

#### Интерпретация

- Некоторые программы не требуют компиляции. Они написаны на языках сценариев, таких как Perl, Python, Ruby, Shell.
- Выполняются специальной программой - интерпретатором.
- Медленнее, чем скомпилированные программы.
- Преимущество - возможность изменения программы без перекомпиляции. Простота и скорость разработки.

#### Компиляция линуксовых программ из исходников

- `ftp ftp.gnu.org` - подключение к FTP-серверу GNU.
- `Name (ftp.gnu.org:me): anonymous` - имя пользователя.
- `ftp> cd gnu/diction` - переход в директорию.
- `ftp> get diction-1.11.tar.gz` - загрузка архива.
- `ftp> quit` - выход.
- `tar xvf diction-1.11.tar.gz` - распаковка архива.
- `cd diction-1.11` - переход в директорию.
- `./configure` - конфигурация программы.
  - Создается файл `Makefile`, который содержит инструкции для компиляции программы для вашей системы.
  - `--prefix=/usr/local` - установка программы в `/usr/local`.
- `make` - компиляция программы.
  - Старается обеспечить актуальность целевых файлов.
  - Гарантирует, что целевые файлы будут более новыми, чем их зависимости.
- `diction` - запуск собранной программы.
- `sudo make install` - установка программы
- `which diction` - проверка установки программы.

## Часть IV. Сценарии командной оболочки

### Глава 24. Создание первого сценария командной оболочки

#### Шаги написания сценария

- Написать новый сценарий через текстовый редактор(vim, gedit).
- Сделать файл исполняемым:
  - `chmod +x script.sh` - добавление прав на исполнение.
  - `chmod 755 script.sh` - установка прав на исполнение - изменять может только владелец.
- Поместить файл в директорию, указанную в переменной окружения `PATH`.
  - `~/bin` - для программ, которые должны быть доступны только вам.
  - `/usr/local/bin` - для программ, которые должны быть доступны всем пользователям.
  - `/usr/local/sbin` - для программ, которые должны быть доступны только суперпользователям.
- Запустить сценарий:
  - Из локальной папки: `./script.sh`.
  - Если лежит в path: `script.sh`.

#### Формат файла сценария

- `#! /bin/bash` - указание интерпретатора должно быть в первой строке (shebang).
- Далее идет текст сценария.
- Используйте длинные имена параметров, потому что они улучшают читаемость кода: `ls -all --directory` вместо `ls -ad`.
- `\` - символ продолжения строки. Позволяет разбить длинные строки на несколько строк.
- Строки в кавычках могут включать символы переноса строки.

### Глава 25. Начало проекта

#### Создание переменной

- `var=value` - создание переменной.
- Чтобы создать переменную достаточно просто использовать имя переменной.
- `declare -r VAR=value` - создание константы.
  - Командная оболочка не раличает константы и переменные.
  - Типичное соглашение - имена констант пишутся заглавными буквами.
- `var` - имя переменной.
- `value` - значение переменной - строка.
- `a="a string"` - используйте двойные кавычки, чтобы присвоить значение, которое содержит пробелы.
- `b="a string with $a"` - переменные внутри строки будут развернуты.
- `e=((5 * 3))` - арифметическое выражение.

#### Обращение к переменной - `$var`

- `echo $unknown` - если переменная не определена, то она будет иметь пустое значение по умолчанию.
- `echo $var` - вывод значения переменной.
- `echo ${var}` - вывод значения переменной.
- `echo ${var}1` - вывод значения переменной с добавлением символа `1`.
- `echo $var1` - возможная ошибка`, надо использовать **фигурные скобки**, если переменная не окружена пробелами.

#### Встроенные документы (here documents) - `<< _EOF_`

- Встроенные документы - это допольнительная форма перенаправления ввода, которая передает текст, встроенный в сценарий, в стандартный ввод команды.
- Встроенные документы могут использоваться с любыми командами, которые принимают ввод из стандартного ввода.
- `cat << _EOF_` - начало встроенного документа.
- `_EOF_` - конец встроенного документа.
- `_EOF_` - это может быть любая строка, которая не встречается в документе.
- Кавычки внутри встроенных документов теряют свое специальное назначение.

```bash
ftp -n << _EOF_
    open $FTP_SERVER
    user anonymous me@linuxbox
    cd $FTP_PATH
    hash
    get $REMOTE_FILE
    bye
_EOF_
ls -l $REMOTE_FILE
```

### Глава 26. Проектирование сверху вниз

- Проектирование сверху вниз - процесс идентификации высокоуровневых шагов и проработка все менее и менее детализированных шагов.

#### Функции в командной оболочке (`function`)

- `function_name() { commands; }` - создание функции.
  - скобки `()` не обязательны.
- `function_name` - вызов функции - скобки не нужны.
- `function_name arg1 arg2` - передача аргументов в функцию. ???
- `$1`, `$2` - аргументы функции.
- `local var=value` - создание локальной переменной, которая доступна только внутри функции, она не затирает глобальные переменные с таким же именем.

```bash
#! /bin/bash

echo "System info"
var=500

foo () {
  echo Hello
  local var=100
  echo "var=$var (local)"
}

foo
echo "var=$var (global)"
```

#### `uptime` - вывод информации о времени работы системы

#### `.bashrc` - используйте для добавления своих функций, чтобы сделать их доступными в интерактивной оболочке

- `~/.bashrc` - файл, который выполняется при запуске интерактивной оболочки.
- Все функции станут доступными для запуска в интерактивной оболочке.

### Глава 27. Управление потоком выполнения: ветвление при помощи if

### Глава 28. Чтение ввода с клавиатуры

### Глава 29. Управление потоком выполнения: циклы while и until

### Глава 30. Поиск и устранение ошибок

### Глава 31. Управление потоком выполнения: ветвление с помощью case

### Глава 32. Позиционные параметры

### Глава 33. Управление потоком выполнения: цикл for

### Глава 34. Строки и числа

### Глава 35. Массивы

### Глава 36. Экзотика
