### 01. Scent Cpp

- `class` используется для объединения данных и методов.
- `template` используется для обобщения данных и методов.
- `STL` - стандартная библиотека имеет массу обобщенных алгоритмов и структур данных.

### 02. Указатели и ссылки

- `ссылка` - это другое имя оъекта. Не может быть `nullptr`.
- `указатель` - это объект, который хранит адрес другого объекта. Может быть `nullptr`.
- `const T&` - только const ссылка может продлевать жизнь временного объекта (rvalue).
- `decaying` - это процесс превращения массива в указатель. Деградация.
- `lvalue` означает locator value. Хотя раньше означало left value, т.е. значение слева от оператора присваивания.
- Переменная в `global scope`  имеет `static storage duration`. `Порядок инициализации` внутри модуля строго сверху вниз. Между модулями порядок не определен.

### 03. Перегрузка. Конструкторы/деструкторы. Копирование/присваивание.

- `mangling` - это процесс преобразования имен функций во что-то уникальное.
- `Строгая гарантия по именам` - ее предоставляет язык Си. В С++ есть `extern "C"`, т.к. в нем нет перегрузки. За это любят Си.
- `Конструкторы можно делегировать` через `: Base(args) {}`.
- Отличие копирования от присваивания: 1. Копирование - создание нового объекта, 2. Присваивание - изменение существующего объекта.
- `volatile` - это квалификатор, который говорит компилятору, что переменная может измениться вне текущего контекста.
- Пользовательские преобразования: 1. Constructor от одного аргумента, 2. Operator преобразования.

### 04. RAII и перемещение

- `operator->` предоставляет доступ к внутренним полям, но не дает доступа к указателю на объект, хотя и возвращает указатель на объект. Как бы зарывается в глубину.
- `move/copy elision` может работать, даже если копирование или перемещение удалены.
- `std::move на return` может убить RVO(Return Value Optimization).
- `Правило пяти` - это 1. Конструктор копирования, 2. Оператор присваивания, 3. Конструктор перемещения, 4. Оператор перемещения, 5. Деструктор.
- `NoCopyMove bar() { return NoCopyMove{}; }` // легально в C++17 - prvalue elision
- `NoCopyMove n = bar();` // легально в C++17 - prvalue elision
- `foo(NoCopyMove{});` // легально в C++17 - обязан делать copy/move elision

- Мои мысли
  - rvalue и lvalue ссылаются на память (стек). Но разница в типе переменной.
  - Знание о типе используется в языке, чтобы отличить временные объекты от постоянных.
  - `Implicit cast` может преобразовать(маркировать?) временный объект в постоянный.
  - `std::move` - может преобразовать(маркировать?) постоянный объект во временный.

### 05. Operators

- Касты: 1. `static_cast`, 2. `dynamic_cast`, 3. `const_cast`, 4. `reinterpret_cast`.
- `Равенство и эквивалентность` - это разные вещи. `==` и `!=` - это равенство. `operator<` - это эквивалентность.
- `->*` или `.*` - это операторы для работы с указателями на члены.
- `operator""` - это пользовательские литералы.

### 06. Inheritance

- `Срезка значения` может происходить, если объект передается по значению.
- `Empty Base Class Optimization` - оптимизация, когда пустой базовый класс не занимает места. Не работает для виртуальных базовых классов.
- `Аргументы по умолчанию` связываются `статически`. `Виртуальные функции` связываются `динамически`.
- `Статический полиморфизм`: 1. Полиморфизм функций, 2. Полиморфизм шаблонов.
- `Динамический полиморфизм` - это полиморфизм через виртуальные функции. Полиморфизм по аргументу `this`.
- `Множественное наследование` и ромбовидность решается через `virtual inheritance`.
- `dynamic_cast` на порядки может быть медленнее, чем `static_cast`. При отсутвии виртуальных функций, `dynamic_cast` работает как `static_cast`.

### 08. Exceptions

- `Гарантии безопасности исключений`: 1. Базовая (нет утечек, но состояние объекта непредсказуемое), 2. Строгая (commit/rollback), 3. noexcept.
- `Условный noexcept` - делается через operator `noexcept`. Не путать с аннотацией `noexcept`.
- `copy and swap` - это идиома для создания exception-safe методов.
- `new` - бывает трех типов: 1. `new`, 2. `nothrow new`, 3. `placement new`.

### 12. Templates

- `rvalue` объект можно передать в `const T&` - это своего рода исключение из праввил.
- `universal reference` - это шаблонный `T&&`. Может быть `lvalue` и `rvalue`, но сам является `lvalue`.
- `std::forward` - это условный `std::move`.
- `decltype` - возвращает тип выражения. Может добавлять `&`.
- `auto` - выводит тип переменной из выражения. Срезает ссылки и квалификаторы. Делает `decay`. Работает по правилам шаблонного вывода.
- `decltype(auto)` - выводит тип переменной из выражения справа. Не делает `decay`.
- `void_t` - это своего рода коньюнкция типов. Проверяет, что все типы легальны, либо Substitution Failure.
- `Итератор`, это объект, у которого есть методы `++`, `*`, `<=>`, `begin`, `end`.
- `declval<T>()` - функция без тела, которая возвращает `T&&`. Она не слинкуется, поэтому ее имеет смысл вызывать только в `decltype`, который просто оценивает тип.

### 13. Vectors

- `Integral Constant` - отражение из целых чисел в типы. `true_type` и `false_type`.
- `Шаблонная триада`: 1. Primary template, 2. Partial specialization, 3. Удобный `using func_t`.
- `{}` инициализация: 1. Агрегат, 2. initializer_list, 3. конструктор.
- `Вариативные шаблоны` захватывают все аргументы, которые не были захвачены ранее.
- Для того, чтобы `SFINAE` подстановка была провалена она `должна быть провалена внутри declaration` (важен контекст подстановки).

### 14. Iterators

- `iterator_traits<iter>::iterator_category` - используются чтобы показать сематическое различие между итераторами, даже если они имеют одинаковый интерфейс.
- `SFINAE IF`: `std::enable_if_t<cond>`
- `SFINAE AND`: `void_t<cond1, cond2>`
- Обязательно тестируйтесь c `std::vector<bool>`, когда делаете адаптеры итераторов, ренджи и т.д.
- Правильная ментальная модель итератора - это стрелочка между элементами: `1  2  3  4->5  6  7`. Это легко объясняет reverse итераторы.
- Итератор на `end` указывает на место, не имеющее значения. Но это не память за пределами массива. В листах это вообще указатель на первый элемент, чтобы зациклить. Просто это Undefined Behaviour и закладываться на это не стоит.
- Обычно не требуется писать собственных контейнеров, итераторов. Достаточно написать `адаптер` существующего.

### 15. Contaners

- Используйте `std::bitset` для битовых операций вместо `std::vector<bool>`.
- `std::string_view` - это view на строку. Не владеет памятью. Хранит указатель и длину. Может провиснуть.
- `std::span` - это view на массив. Тоже что и `std::string_view` для `std::string`, но для массивов.
- Вероятно, что `std::ref(std::vector)` заменяет `std::span`. `TODO`
- `strick weak ordering` - если `a < b` и `b < a` - это значит, что `a == b`.
- `std::iota` - заполняет диапазон последовательными значениями.
- `un_set.insert(vec.begin(), vec.end())` - вставляет элементы из вектора в неупорядоченное множество. Дубликаты не вставляются. При этом поиск элемента во множестве происходит за `O(1)`.
- Если вам достаточно `==` на элементах, то используйте `unordered` контейнеры.
- Если вам нужен `operator<` на элементах, то используйте `ordered` контейнеры (ренджи). `lower_bound`, `upper_bound`, `equal_range` методы.
- `std::map::erase` - возвращает итератор на следующий элемент. Это удобно для удаления элементов в процессе итерирования.
- Для замены элемента в дереве используйте удаление и вставку: `erase` и `insert`.

### 17.  Algorithms

- До С++17 `std::cout << foo1() << foo2();` мог запускать `foo1` и `foo2` в произвольном порядке. С С++17 порядок гарантирован.
- Lambda
  - `mutable` у лямбды делает функцию `operator()` неконстантной. По умолчанию `operator()` константный.
  - Глобальные и статические переменные захватывать в лямбду не надо, они всегда как будто захвачены по ссылке.
  - Захват с переименованием может быть очень полезен: `[foo = bar] () {}`.
  - Захват с переименованием позволяет захватить правую ссылку: `[foo = std::move(bar)] () {}`.
  - Лямбда функция без захвата естественным образом приводится к указателю на функцию.
  - Список захвата выполняется в момент создания лямбды, а не в момент вызова.
- `std::function`
  - `std::function<int()> f = [&x, &y] { return x + y; };` - происходит **стирание захвата**. Т.е. это единый тип, к которому приводятся все замыкания с данной сигнатурой.
  - `std::function` - делает лишний уровень косвенности. Он **выделяет динамическую память под захват**. Это похоже на механизм виртуальных функций (только вместо таблицы виртуальных функций - **таблица захвата**).
  - `std::function` - хранит внутри себя настоящий тип, который он стирает. `target_type()` - возвращает манглированную `type_info` настоящего типа. `c++filt -t <magnling name>` - декодирует манглированное имя.
  - Плюсы в том, что у нас единая сигнатура, минусы в том, что мы ходим через лишний уровень косвенности в динамической памяти.
- Algorithms
  - Ни в один `copy-подобный алгоритм` нельзя указывать `выходной итератор` посередине `входного диапазона`. `std::copy_backward` выкручивается так, что он принимает `итератор в конец выходного диапазона` и `копирует в обратном порядке`.
