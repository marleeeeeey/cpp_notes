### 01. Строки

- `SSO` (Small String Optimazations) делает так, что `data` ссылается на память на `стеке`, где находится короткая строка.

### 02. Functions template

- Статический полиморфизм: множество перегрузок и шаблон функции. Динамический полиморфизм: виртуальная фукнция.
- Вместо слова `typename` можно использовать `имя концепта`: `template <std::integral T> void foo(T t)`.
- `Инстанцирование` - это процесс порождения экземпляра специализации. Может быть `явным` или `неявным`.
- `non-type template parameter` можно также **параметризовать указателями** на `nullptr`, на `глобальную память` или `статические объекты`.
- **Выбор пользовательского преобразования зависит от длины хвоста стандартных преобразований**. Голова не участвует в конкурсе.

### 03. Class template

- Переходник типов `Type2Type<T1>` - позволяет решить проблему специализации метода класса по параметру шаблона класса
- Можно использовать `iterator_traits<Iter>::value_type`, а можно написать просто `Iter::value_type`. Однако `iterator_traits` предпочтительнее, потому что он умеет выводить типы для указателей, у которых нет вложенного типа `value_type`.
- **Конструкторы** классов могут использоваться для **вывода типов шаблона класса**.
- `Deduction Hints` - хинты вывода типов могут быть использованы для вывода типов `конструкторами классов` и `агрегатами` (С++17).
