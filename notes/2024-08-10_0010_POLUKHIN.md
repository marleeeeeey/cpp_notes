# Antony Polukhin - Guru C++

- [About the author](#about-the-author)
- [Антон Полухин - Как делать не надо. Велосипедостроение для профессионалов, C++ User Group - 2016](#антон-полухин---как-делать-не-надо-велосипедостроение-для-профессионалов-c-user-group---2016)
  - [`memmove` гарантирует корректное копирование даже при перекрытии областей памяти](#memmove-гарантирует-корректное-копирование-даже-при-перекрытии-областей-памяти)
  - [`std::variant` - класс который хранит один из типов T, и помнит тип данных](#stdvariant---класс-который-хранит-один-из-типов-t-и-помнит-тип-данных)
  - [Три независимых кэша процессора](#три-независимых-кэша-процессора)
  - [Force Inline может негативно сказаться на производительности из-за кэш-промахов](#force-inline-может-негативно-сказаться-на-производительности-из-за-кэш-промахов)
  - [`no strict aliasing` - это плохая практика](#no-strict-aliasing---это-плохая-практика)
  - [Как правильно инициализировать глобальные константы](#как-правильно-инициализировать-глобальные-константы)
  - [Улучшение кода: `anonymous namespace`, `final`, `override`](#улучшение-кода-anonymous-namespace-final-override)
  - [Правильный move-конструктор: `= default` и `noexcept`](#правильный-move-конструктор--default-и-noexcept)
- [Антон Полухин - C++ на практике, C++ Siberia - 2019](#антон-полухин---c-на-практике-c-siberia---2019)
  - [`boost::interprocess::mapped_region` для ускорения работы с памятью на диске](#boostinterprocessmapped_region-для-ускорения-работы-с-памятью-на-диске)
- [Антон Полухин — Анатомия асинхронных движков - 2022](#антон-полухин--анатомия-асинхронных-движков---2022)
  - [Корутины (coroutines) в C++](#корутины-coroutines-в-c)
  - [`char8_t` (C++20), `mmap`, `ASIO`, `Beast`, `AFIO`](#char8_t-c20-mmap-asio-beast-afio)
  - [Примитивы синхронизации в C++: RCU, Shared Mutex, Semaphore, std::mutex, Condition Variable](#примитивы-синхронизации-в-c-rcu-shared-mutex-semaphore-stdmutex-condition-variable)

## About the author

- [Antony Polukhin](https://github.com/apolukhin)
- [Boost Code Samples](submodules/apolukhin_boost_code/)

## Антон Полухин - Как делать не надо. Велосипедостроение для профессионалов, C++ User Group - 2016

### `memmove` гарантирует корректное копирование даже при перекрытии областей памяти

```c
void *memmove(void *dest, const void *src, size_t n);
```

- `memmove` безопасно обрабатывает случаи, когда области памяти `src` и `dest` перекрываются.
- В случае перекрытия `memmove` сначала копирует данные во временный буфер.

```c
#include <string.h>
#include <stdio.h>

int main() {
    char str[] = "abcdef";

    // Копируем часть строки в другую часть этой же строки
    memmove(str + 2, str, 4);

    printf("%s\n", str);  // Вывод: "ababcd"

    return 0;
}
```

### `std::variant` - класс который хранит один из типов T, и помнит тип данных

- При присвоении нового типа данных уже объекту, который имеет другой тип, прошлый объект будет корректно удален, новый будет корректно записан, индекс будет изменен.

```cpp
union {
    T0 v0;
    T1 v1;
    T2 v2;
    // ...
};

int t_index;
```

### Три независимых кэша процессора

- У процессора есть не только кэш данных
- Большинство современных микропроцессоров для компьютеров и серверов имеют как минимум три независимых кэша:
  - **кэш инструкций** для ускорения загрузки машинного кода,
  - **кэш данных** для ускорения чтения и записи данных и
  - буфер ассоциативной трансляции (**TLB**) для ускорения трансляции виртуальных (логических) адресов в физические, как для инструкций, так и для данных.
- https://ru.wikipedia.org/wiki/Кэш_процессора
- Зачастую, **производительность системы ограничена не скоростью процессора, а производительностью подсистемы памяти**. В то время, как традиционно компиляторы уделяли большее внимание оптимизации работы процессора, сегодня большой упор следует делать на более эффективное использование иерархии памяти

### Force Inline может негативно сказаться на производительности из-за кэш-промахов

- Использование `Force Inline` в современных компиляторах может быть неэффективным, так как компиляторы уже достаточно умны, чтобы самостоятельно решать, когда лучше заинлайнить функцию.
- `Force Inline` может ухудшить использование кэша, так как компилятор будет вынужден загружать в кэш все новые и новые функции, что может привести к снижению производительности из-за частого обращения к памяти.

### `no strict aliasing` - это плохая практика

- **Strict aliasing** — это правило оптимизации в C++, которое позволяет компилятору предполагать, что два указателя разных типов не ссылаются на один и тот же объект в памяти.
- Например, согласно правилу strict aliasing, если у вас есть два указателя типа `int*` и `float*`, то компилятор **может предполагать, что они не ссылаются на один и тот же участок памяти**.
- Это предположение **позволяет компилятору более агрессивно оптимизировать код**, так как он может исключить необходимость учитывать возможные пересечения данных между этими указателями.
- Правило не распространяется на указатели типа **`char*`, `unsigned char*` и `std::byte*`**. Они **могут ссылаться на любую область памяти**, и это разрешено.
- Если у двух типов одинаковый layout в памяти (например, `union`), то доступ к этим типам через один и тот же участок памяти допускается.
- Можно использовать компиляторские флаги (например, `-fno-strict-aliasing` в GCC), но это может негативно повлиять на производительность и надежность кода.

```cpp
bar qwe(foo& f, const bar& b) {
    // load b
    // load f
    f += b;             // &f == &b ???
    // load b           // Повторная загрузка b из-за предположения о strict aliasing
    return b + b;
}
```

### Как правильно инициализировать глобальные константы

- `constexpr` указывает, что мы хотим сделать эту инициализацию до времени выполнения (runtime).
- Такой подход уважает `namespace` и сохраняет типы данных, в отличие от `#define`.

```cpp
constexpr std::string_view CONSTANTS[] = {
    "Hello",
    "World",
    "!"
};
```

### Улучшение кода: `anonymous namespace`, `final`, `override`

- Следующие оптимизации позволяют дать больше информации компилятору по оптимизациям и также могут ускорить загрузку кода, потому что компилятор будет понимать, что этот метод не виден наружу.

```cpp
// something.cpp

namespace {                                     // (1) Анонимное пространство имен
    struct some_implementation final : base {   // (2) Используем final, если не планируем наследование
        // ...
        void act() override { /* ... */ }       // (3) Используем override
    };
} // anonymous namespace
```

### Правильный move-конструктор: `= default` и `noexcept`

- Не нужно забывать писать `noexcept` на `move` конструкторах и делать `std::move` аргумента.
- Но также нужно иметь в виду, что можно написать `= default`, и компилятор проставит `noexcept` и `constexpr` если это возможно.

```cpp
class my_data_struct {
    std::vector<int> data_;
public:
    // ...
    my_data_struct(my_data_struct&&) = default;  // <<=====
};
```

## Антон Полухин - C++ на практике, C++ Siberia - 2019

### `boost::interprocess::mapped_region` для ускорения работы с памятью на диске

- `boost::interprocess::mapped_region`
  - позволяет в C++ программе работать с памятью, которая напрямую ссылается на память на диске, что устраняет необходимость промежуточного копирования данных в оперативную память.
  - Это особенно полезно для работы с большими файлами, такими как лог-файлы, поскольку позволяет эффективно управлять памятью.
  - Вы можете использовать `std::string_view` для работы с этой памятью, что делает процесс более эффективным по сравнению с использованием традиционного `std::ifstream`, который требует копирования данных в оперативную память.

## Антон Полухин — Анатомия асинхронных движков - 2022

### Корутины (coroutines) в C++

- **Эффективность использования потоков:** Корутины позволяют освобождать потоки для выполнения других задач, пока ожидается результат асинхронной операции.
- **Удобство написания кода:** Корутины позволяют писать код, который выглядит линейно, но работает асинхронно, что упрощает поддержку и разработку.
- **Масштабируемость:** Асинхронный код позволяет эффективнее использовать системные ресурсы, особенно при работе с I/O операциями, сетевыми запросами и таймерами.

### `char8_t` (C++20), `mmap`, `ASIO`, `Beast`, `AFIO`

**char8_t в C++20** - Тип `char8_t` введен для работы с UTF-8, чтобы однозначно определять и обрабатывать текстовые данные в этой кодировке.
**mmap** - Memory-mapped файл позволяет работать с файлами как с областями памяти, что ускоряет операции чтения и записи.
**ASIO** - Асинхронная библиотека для ввода-вывода, позволяющая эффективно управлять сетевыми и файловыми операциями.
**Beast** - Библиотека на базе ASIO для работы с HTTP и WebSocket протоколами.
**AFIO** - Асинхронная работа с файлами, обеспечивающая неблокирующее выполнение операций с файловой системой.

### Примитивы синхронизации в C++: RCU, Shared Mutex, Semaphore, std::mutex, Condition Variable

1. **RCU (Read-Copy-Update)**:
   - Это техника синхронизации, которая позволяет потокам читать данные без блокировок, даже если другой поток модифицирует данные. Основная идея заключается в создании копии данных при их изменении, так что другие потоки продолжают работать с неизмененной версией, пока модификации не завершены. Это полезно в системах, где важно минимизировать время блокировок на чтение.

2. **Shared Mutex (std::shared_mutex)**:
   - Это тип мьютекса, который позволяет одновременно нескольким потокам читать данные, но блокирует все потоки на запись. Это полезно, когда у вас есть ресурсы, которые часто читаются и редко изменяются. `std::shared_mutex` был добавлен в C++17 и предоставляет методы `lock_shared()` для блокировки на чтение и `lock()` для блокировки на запись.

3. **Semaphore (семафоры)**:
   - Семафор — это примитив синхронизации, который управляет доступом к ресурсу путем подсчета количества разрешенных операций. Он может быть бинарным (двоичный семафор) или подсчитывающим, где счетчик указывает количество потоков, которым разрешено одновременно использовать ресурс. В отличие от мьютексов, семафоры могут позволить доступ к ресурсу нескольким потокам одновременно, что может быть полезно в определенных сценариях.

4. **std::mutex**:
   - `std::mutex` — это примитив синхронизации, который позволяет одному потоку получить доступ к критической секции кода, блокируя доступ для других потоков. Когда поток захватывает мьютекс, другие потоки, которые пытаются захватить тот же мьютекс, будут ждать, пока он не будет освобожден.

5. **Condition Variable (условная переменная)**:
   - Условные переменные позволяют потокам ожидать определенного условия. Поток может освободить мьютекс и ждать сигнала от другого потока, что условие выполнено. Это полезно для организации взаимодействия между потоками.
