# Gregory - Game Engine Architecture

- [ЧАСТЬ I. ОСНОВЫ](#часть-i-основы)
- [Глава 3. Основы разработки игрового ПО](#глава-3-основы-разработки-игрового-по)
  - [3.1. Обзор C++ и лучшие практики](#31-обзор-c-и-лучшие-практики)
  - [3.2. Поиск и обработка ошибок](#32-поиск-и-обработка-ошибок)
  - [3.3. Данные, код и схема памяти](#33-данные-код-и-схема-памяти)
  - [3.4. Основы аппаратного обеспечения компьютеров](#34-основы-аппаратного-обеспечения-компьютеров)
  - [3.5. Архитектура памяти](#35-архитектура-памяти)
- [Глава 4. Параллелизм и конкурентное программирование](#глава-4-параллелизм-и-конкурентное-программирование)
  - [4.1. Определение конкурентности и параллелизма](#41-определение-конкурентности-и-параллелизма)
  - [4.2. Неявный параллелизм](#42-неявный-параллелизм)
  - [4.3. Явный параллелизм](#43-явный-параллелизм)
  - [4.4. Основы операционной системы](#44-основы-операционной-системы)
  - [4.5. Введение в параллельное программирование](#45-введение-в-параллельное-программирование)
  - [4.6. Примитивы синхронизации потоков](#46-примитивы-синхронизации-потоков)
  - [4.7. Проблемы с параллелизмом на основе блокировки](#47-проблемы-с-параллелизмом-на-основе-блокировки)
  - [4.8. Несколько лучших практик параллелизма](#48-несколько-лучших-практик-параллелизма)
  - [4.9. Параллелизм без блокировок](#49-параллелизм-без-блокировок)
  - [4.10. SIMD/векторная обработка](#410-simdвекторная-обработка)
  - [4.11. Введение в программирование GPGPU](#411-введение-в-программирование-gpgpu)
- [Глава 5. 3D-математика для игр](#глава-5-3d-математика-для-игр)
  - [5.1. Решение 3D-задач в 2D](#51-решение-3d-задач-в-2d)
  - [5.2. Точки и векторы](#52-точки-и-векторы)
  - [5.3. Матрицы](#53-матрицы)
  - [5.4. Кватернионы](#54-кватернионы)
  - [5.5. Сравнение представлений вращения](#55-сравнение-представлений-вращения)
  - [5.6. Другие полезные математические объекты](#56-другие-полезные-математические-объекты)
  - [5.7. Генерация случайных чисел](#57-генерация-случайных-чисел)
- [ЧАСТЬ II. НИЗКОУРОВНЕВЫЕ СИСТЕМЫ ДВИЖКА](#часть-ii-низкоуровневые-системы-движка)
- [Глава 6. Системы поддержки движка](#глава-6-системы-поддержки-движка)
  - [6.1. Подсистема запуска и остановки](#61-подсистема-запуска-и-остановки)
  - [6.2. Управление памятью](#62-управление-памятью)
  - [6.3. Контейнеры](#63-контейнеры)
  - [6.4. Строки](#64-строки)
  - [6.5. Конфигурация движка](#65-конфигурация-движка)
- [Глава 7. Ресурсы и файловая система](#глава-7-ресурсы-и-файловая-система)
  - [7.1. Файловая система](#71-файловая-система)
  - [7.2. Менеджер ресурсов](#72-менеджер-ресурсов)
- [Глава 8. Игровой цикл и симуляция в реальном времени](#глава-8-игровой-цикл-и-симуляция-в-реальном-времени)
  - [8.1. Цикл рендеринга](#81-цикл-рендеринга)
  - [8.2. Цикл игры](#82-цикл-игры)
  - [8.3. Архитектурные стили цикла игры](#83-архитектурные-стили-цикла-игры)
  - [8.4. Абстрактные временные шкалы](#84-абстрактные-временные-шкалы)
  - [8.5. Измерение времени и работа с ним](#85-измерение-времени-и-работа-с-ним)
  - [8.6. Многопроцессорные игровые циклы](#86-многопроцессорные-игровые-циклы)

## ЧАСТЬ I. ОСНОВЫ

## Глава 3. Основы разработки игрового ПО

### 3.1. Обзор C++ и лучшие практики

- Про наличие классов и ООП.
- Вероятно использование auto повсюду может усложнить чтение кода. Используйте его с итераторами и контейнерами.
- Изучайте стандарты языка С++, но с умом переходите на более новые для использования конкретных возможностей.

### 3.2. Поиск и обработка ошибок

- 3.2.1. Типы ошибок
- 3.2.2. Обработка ошибок
- 3.2.3. Реализация обнаружения ошибок и их обработки

### 3.3. Данные, код и схема памяти

- 3.3.1. Числовые представления
- 3.3.2. Примитивные типы данных
- 3.3.3. Килобайт или кибибайт
- 3.3.4. Объявления, определения и компоновка
- 3.3.5. Структура памяти программы C/C++
- 3.3.6. Переменные-члены
- 3.3.7. Расположение объектов в памяти

### 3.4. Основы аппаратного обеспечения компьютеров

- 3.4.1. Обучение на более простых компьютерах прошлых лет
- 3.4.2. Архитектура компьютера
- 3.4.3. Центральный процессор
- 3.4.4. Частота
- 3.4.5. Память
- 3.4.6. Шины
- 3.4.7. Машинный и ассемблерный языки

### 3.5. Архитектура памяти

- 3.5.1. Сопоставление памяти
- 3.5.2. Виртуальная память
- 3.5.3. Архитектуры памяти для уменьшения задержки
- 3.5.4. Иерархии кэш-памяти
- 3.5.5. Неоднородный доступ к памяти

## Глава 4. Параллелизм и конкурентное программирование

### 4.1. Определение конкурентности и параллелизма

- 4.1.1. Конкурентное выполнение
- 4.1.2. Параллелизм
- 4.1.3. Параллелизм данных и задач
- 4.1.4. Таксономия Флинна
- 4.1.5. Ортогональность конкурентных вычислений и параллелизма
- 4.1.6. Вопросы, рассматриваемые в главе

### 4.2. Неявный параллелизм

- 4.2.1. Конвейерная обработка
- 4.2.2. Задержка и пропускная способность
- 4.2.3. Глубина конвейера
- 4.2.4. Потеря скорости конвейера
- 4.2.5. Зависимости данных
- 4.2.6. Зависимости ветвления
- 4.2.7. Суперскалярные процессоры
- 4.2.8. Очень длинные командные слова

### 4.3. Явный параллелизм

- 4.3.1. Гиперпоточность
- 4.3.2. Многоядерные процессоры
- 4.3.3. Симметричная и асимметричная многопроцессорная обработка
- 4.3.4. Распределенные вычисления

### 4.4. Основы операционной системы

- 4.4.1. Ядро
- 4.4.2. Прерывания
- 4.4.3. Вызовы ядра
- 4.4.4. Вытесняющая многозадачность
- 4.4.5. Процессы
- 4.4.6. Потоки
- 4.4.7. Фиберы
- 4.4.8. Потоки пользовательского уровня и корутины
- 4.4.9. Что еще почитать о процессах и потоках

### 4.5. Введение в параллельное программирование

- 4.5.1. Зачем писать параллельное программное обеспечение
- 4.5.2. Модели параллельного программирования
- 4.5.3. Состояние гонки
- 4.5.4. Критические операции и атомарность

### 4.6. Примитивы синхронизации потоков

- 4.6.1. Мьютексы
- 4.6.2. Критически важные секции
- 4.6.3. Переменные условия
- 4.6.4. Семафоры
- 4.6.5. События Windows

### 4.7. Проблемы с параллелизмом на основе блокировки

- 4.7.1. Взаимная блокировка
- 4.7.2. Динамическая взаимная блокировка
- 4.7.3. Ресурсное голодание
- 4.7.4. Инверсия приоритетов
- 4.7.5. Обедающие философы

### 4.8. Несколько лучших практик параллелизма

- 4.8.1. Правила глобального порядка
- 4.8.2. Алгоритмы на основе транзакций
- 4.8.3. Минимизация раздоров
- 4.8.4. Безопасность потоков

### 4.9. Параллелизм без блокировок

- 4.9.1. Причины ошибок в гонке данных
- 4.9.2. Реализация атомарности
- 4.9.3. Барьеры
- 4.9.4. Семантика упорядочения памяти
- 4.9.5. Атомарные переменные
- 4.9.6. Параллельность в интерпретируемых языках программирования
- 4.9.7. Спин-блокировки
- 4.9.8. Транзакции без блокировок
- 4.9.9. Связанный список без блокировки
- 4.9.10. Дополнительная литература по программированию без блокировок

### 4.10. SIMD/векторная обработка

- 4.10.1. Набор инструкций SSE и его регистры
- 4.10.2. Использование SSE для векторизации цикла
- 4.10.3. Векторизованное скалярное произведение
- 4.10.4. Векторно-матричное умножение с помощью SSE
- 4.10.5. Матрица-матричное умножение с SSE
- 4.10.6. Обобщенная векторизация
- 4.10.7. Предикация векторов

### 4.11. Введение в программирование GPGPU

- 4.11.1. Параллельные вычисления данных
- 4.11.2. Вычислительные ядра
- 4.11.3. Выполнение ядра
- 4.11.4. Потоки GPU и группы потоков
- 4.11.5. Дополнительная литература

## Глава 5. 3D-математика для игр

### 5.1. Решение 3D-задач в 2D

### 5.2. Точки и векторы

- 5.2.1. Точки и декартовы координаты
- 5.2.2. Левосторонние и правосторонние системы координат
- 5.2.3. Векторы
- 5.2.4. Векторные операции
- 5.2.5. Линейная интерполяция точек и векторов

### 5.3. Матрицы

- 5.3.1. Умножение матриц
- 5.3.2. Представление точек и векторов в виде матриц
- 5.3.3. Единичная матрица
- 5.3.4. Инвертирование матриц
- 5.3.5. Транспонирование
- 5.3.6. Однородная система координат
- 5.3.7. Матрицы базовых преобразований
- 5.3.8. Матрицы 4 × 3
- 5.3.9. Координатное пространство
- 5

.3.10. Переход к новому базису
- 5.3.11. Преобразование векторов нормали
- 5.3.12. Хранение матриц в памяти

### 5.4. Кватернионы

- 5.4.1. Единичные кватернионы как трехмерные вращения
- 5.4.2. Операции с кватернионами
- 5.4.3. Вращение векторов через кватернионы
- 5.4.4. Кватернионно-матричная эквивалентность
- 5.4.5. Линейная интерполяция вращения

### 5.5. Сравнение представлений вращения

- 5.5.1. Углы Эйлера
- 5.5.2. Матрицы 3 × 3
- 5.5.3. Ось + угол
- 5.5.4. Кватернионы
- 5.5.5. Преобразования SRT
- 5.5.6. Двойные кватернионы
- 5.5.7. Вращения и степени свободы

### 5.6. Другие полезные математические объекты

- 5.6.1. Прямые, лучи и отрезки
- 5.6.2. Сферы
- 5.6.3. Плоскости
- 5.6.4. Параллельные осям ограничивающие параллелепипеды
- 5.6.5. Ориентированные ограничивающие параллелепипеды
- 5.6.6. Усеченная пирамида
- 5.6.7. Выпуклые многогранные области

### 5.7. Генерация случайных чисел

- 5.7.1. Линейные конгруэнтные генераторы
- 5.7.2. Вихрь Мерсенна
- 5.7.3. Мать всего, Xorshift и KISS99
- 5.7.4. PCG

## ЧАСТЬ II. НИЗКОУРОВНЕВЫЕ СИСТЕМЫ ДВИЖКА

## Глава 6. Системы поддержки движка

### 6.1. Подсистема запуска и остановки

- 6.1.1. Порядок статической инициализации C++ (или его отсутствие)
- 6.1.2. Простой работающий подход
- 6.1.3. Некоторые примеры реальных движков

### 6.2. Управление памятью

- 6.2.1. Оптимизация динамического распределения памяти
- 6.2.2. Фрагментация памяти

### 6.3. Контейнеры

- 6.3.1. Операции с контейнерами
- 6.3.2. Итераторы
- 6.3.3. Алгоритмическая сложность
- 6.3.4. Создание пользовательских контейнерных классов
- 6.3.5. Динамические массивы и выделение памяти фрагментами
- 6.3.6. Словари и хеш-таблицы

### 6.4. Строки

- 6.4.1. Проблема со строками
- 6.4.2. Классы строк
- 6.4.3. Уникальные идентификаторы
- 6.4.4. Локализация

### 6.5. Конфигурация движка

- 6.5.1. Параметры загрузки и сохранения
- 6.5.2. Параметры для каждого пользователя
- 6.5.3. Управление конфигурацией в некоторых реальных движках

## Глава 7. Ресурсы и файловая система

### 7.1. Файловая система

- 7.1.1. Имена файлов и пути к ним
- 7.1.2. Базовый файловый ввод/вывод
- 7.1.3. Асинхронный файловый ввод/вывод

### 7.2. Менеджер ресурсов

- 7.2.1. Автономное управление ресурсами и цепочка инструментов
- 7.2.2. Управление ресурсами среды выполнения

## Глава 8. Игровой цикл и симуляция в реальном времени

### 8.1. Цикл рендеринга

### 8.2. Цикл игры

- 8.2.1. Простой пример: пинг-понг

### 8.3. Архитектурные стили цикла игры

- 8.3.1. Конвейер сообщений Windows
- 8.3.2. Фреймворки на основе обратных вызовов
- 8.3.3. Обновление на основе событий

### 8.4. Абстрактные временные шкалы

- 8.4.1. Реальное время
- 8.4.2. Игровое время
- 8.4.3. Локальное и глобальное время

### 8.5. Измерение времени и работа с ним

- 8.5.1. Частота смены кадров и время
- 8.5.2. От частоты кадров к скорости
- 8.5.3. Измерение реального времени с помощью таймера высокого разрешения
- 8.5.4. Единицы измерения времени и переменные часов
- 8.5.5. Работа с точками останова

### 8.6. Многопроцессорные игровые циклы

- 8.6.1. Разложение задания
- 8.6.2. Один поток на подсистему
- 8.6.3. Разбиение/сборка
- 8.6.4. Система заданий
