### `memmove` гарантирует корректное копирование даже при перекрытии областей памяти

```c
void *memmove(void *dest, const void *src, size_t n);
```

- `memmove` безопасно обрабатывает случаи, когда области памяти `src` и `dest` перекрываются.
- В случае перекрытия `memmove` сначала копирует данные во временный буфер.

```c
#include <string.h>
#include <stdio.h>

int main() {
    char str[] = "abcdef";

    // Копируем часть строки в другую часть этой же строки
    memmove(str + 2, str, 4);

    printf("%s\n", str);  // Вывод: "ababcd"

    return 0;
}
```

### `std::variant` - класс который хранит один из типов T, и помнит тип данных

- При присвоении нового типа данных уже объекту, который имеет другой тип, прошлый объект будет корректно удален, новый будет корректно записан, индекс будет изменен.

```cpp
union {
    T0 v0;
    T1 v1;
    T2 v2;
    // ...
};

int t_index;
```

### Три независимых кэша процессора

- У процессора есть не только кэш данных
- Большинство современных микропроцессоров для компьютеров и серверов имеют как минимум три независимых кэша:
  - **кэш инструкций** для ускорения загрузки машинного кода,
  - **кэш данных** для ускорения чтения и записи данных и
  - буфер ассоциативной трансляции (**TLB**) для ускорения трансляции виртуальных (логических) адресов в физические, как для инструкций, так и для данных.
- https://ru.wikipedia.org/wiki/Кэш_процессора
- Зачастую, **производительность системы ограничена не скоростью процессора, а производительностью подсистемы памяти**. В то время, как традиционно компиляторы уделяли большее внимание оптимизации работы процессора, сегодня большой упор следует делать на более эффективное использование иерархии памяти

### Force Inline может негативно сказаться на производительности из-за кэш-промахов

- Использование `Force Inline` в современных компиляторах может быть неэффективным, так как компиляторы уже достаточно умны, чтобы самостоятельно решать, когда лучше заинлайнить функцию.
- `Force Inline` может ухудшить использование кэша, так как компилятор будет вынужден загружать в кэш все новые и новые функции, что может привести к снижению производительности из-за частого обращения к памяти.

### `no strict aliasing` - это плохая практика

- **Strict aliasing** — это правило оптимизации в C++, которое позволяет компилятору предполагать, что два указателя разных типов не ссылаются на один и тот же объект в памяти.
- Например, согласно правилу strict aliasing, если у вас есть два указателя типа `int*` и `float*`, то компилятор **может предполагать, что они не ссылаются на один и тот же участок памяти**.
- Это предположение **позволяет компилятору более агрессивно оптимизировать код**, так как он может исключить необходимость учитывать возможные пересечения данных между этими указателями.
- Правило не распространяется на указатели типа **`char*`, `unsigned char*` и `std::byte*`**. Они **могут ссылаться на любую область памяти**, и это разрешено.
- Если у двух типов одинаковый layout в памяти (например, `union`), то доступ к этим типам через один и тот же участок памяти допускается.
- Можно использовать компиляторские флаги (например, `-fno-strict-aliasing` в GCC), но это может негативно повлиять на производительность и надежность кода.

```cpp
bar qwe(foo& f, const bar& b) {
    // load b
    // load f
    f += b;             // &f == &b ???
    // load b           // Повторная загрузка b из-за предположения о strict aliasing
    return b + b;
}
```

### Как правильно инициализировать глобальные константы

- `constexpr` указывает, что мы хотим сделать эту инициализацию до времени выполнения (runtime).
- Такой подход уважает `namespace` и сохраняет типы данных, в отличие от `#define`.

```cpp
constexpr std::string_view CONSTANTS[] = {
    "Hello",
    "World",
    "!"
};
```

### Улучшение кода: `anonymous namespace`, `final`, `override`

- Следующие оптимизации позволяют дать больше информации компилятору по оптимизациям и также могут ускорить загрузку кода, потому что компилятор будет понимать, что этот метод не виден наружу.

```cpp
// something.cpp

namespace {                                     // (1) Анонимное пространство имен
    struct some_implementation final : base {   // (2) Используем final, если не планируем наследование
        // ...
        void act() override { /* ... */ }       // (3) Используем override
    };
} // anonymous namespace
```

### Правильный move-конструктор: `= default` и `noexcept`

- Не нужно забывать писать `noexcept` на `move` конструкторах и делать `std::move` аргумента.
- Но также нужно иметь в виду, что можно написать `= default`, и компилятор проставит `noexcept` и `constexpr` если это возможно.

```cpp
class my_data_struct {
    std::vector<int> data_;
public:
    // ...
    my_data_struct(my_data_struct&&) = default;  // <<=====
};
```
